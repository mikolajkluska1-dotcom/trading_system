=== REDLINE PROJECT SCAN ===
Root: C:\Users\user\Desktop\trading_system

=== FILE STRUCTURE ===
[trading_system/]
    package-lock.json
    redline_scan.txt
    requirements.txt
    reset.py
    scan_project.py
    [archive/]
        [streamlit_ui/]
            app.py
            [ui/]
                admin.py
                auth.py
                dashboard.py
                hud.py
                scanner_view.py
                shared.py
                styles.py
                training_view.py
                wallet.py
                __init__.py
                [js/]
                    events_investor.js
                    events_ops.js
                    event_renderer.js
    [assets/]
        honeypot.txt
        redline.key
        training_report.json
        users_db.json
        wallet.enc
        [ops_logs/]
            2026-01-06.jsonl
    [backend/]
        ai_core.py
        auth.py
        events_server.py
        hud_server.py
        main.py
    [core/]
        auto_rotator.py
        bootstrap.py
        config.py
        event_logger.py
        logger.py
        orchestrator.py
        security.py
        __init__.py
    [data/]
        feed.py
        indicators.py
        news.py
        __init__.py
    [frontend/]
        index.html
        package-lock.json
        package.json
        vite.config.js
        [src/]
            App.jsx
            main.jsx
            [api/]
                auth.js
                client.js
                system.js
                trading.js
            [auth/]
                AuthContext.jsx
                RequireRole.jsx
                useAuth.js
            [components/]
                [Charts/]
                [Controls/]
                [Events/]
                    EventCard.jsx
                    EventOverlay.jsx
                [HUD/]
                    HUD.jsx
                    HudItem.jsx
                    HudMinimal.jsx
                [Tables/]
            [config/]
                endpoints.js
                roles.js
                settings.js
            [layouts/]
                InvestorLayout.jsx
                MinimalLayout.jsx
                OpsLayout.jsx
            [styles/]
                globals.css
                ops.css
                theme.js
            [utils/]
                format.js
                math.js
                time.js
            [views/]
                InvestorDashboard.jsx
                login.jsx
                OpsDashboard.jsx
                scanner.jsx
                system.jsx
                training.jsx
                wallet.jsx
            [ws/]
                hud.js
                reconnect.js
                useEvents.js
    [ml/]
        brain.py
        knowledge.py
        regime.py
        scanner.py
        training.py
        __init__.py
    [redteam/]
        audit.py
        chaos.py
        exchange.py
        forensics.py
        manipulation.py
        osint.py
        __init__.py
    [security/]
        hardware.py
        network.py
        user_manager.py
        vault.py
        __init__.py
    [trading/]
        analytics.py
        capital.py
        decision.py
        execution.py
        position_manager.py
        wallet.py
        __init__.py

=== FILE CONTENTS ===

==================================================
FILE: reset.py
==================================================
import json
import os
import hashlib

# 1. KONFIGURACJA ODZYSKIWANIA
ADMIN_PASS = "Cyber_Fortress_X1"
OVERRIDE_PASS = "Redline_OMEGA_99!"
SALT = "X9vL2_REDLINE_STATIC_SALT"

def fix_users_db():
    print(f"ðŸ”§ [1/2] Naprawianie bazy uÅ¼ytkownikÃ³w (assets/users_db.json)...")

    # Hashowanie hasÅ‚a admina (ZwykÅ‚e SHA-256, bez soli - tak jak w ui/auth.py)
    admin_hash = hashlib.sha256(ADMIN_PASS.encode()).hexdigest()

    db_structure = {
        "active": {
            "admin": {
                "hash": admin_hash,
                "role": "ROOT",
                "allowed_ips": [] # Pusta lista wymusi Override przy nowym IP
            }
        },
        "pending": {}
    }

    if not os.path.exists("assets"):
        os.makedirs("assets")

    with open(os.path.join("assets", "users_db.json"), "w") as f:
        json.dump(db_structure, f, indent=4)

    print(f"âœ… Baza naprawiona. Login: admin | HasÅ‚o: {ADMIN_PASS}")

def fix_config_hash():
    print(f"ðŸ”§ [2/2] Generowanie Hasha dla Configu...")

    # Hashowanie Override Code (HasÅ‚o + SÃ³l - tak jak w ui/auth.py sekcja Override)
    combined = OVERRIDE_PASS + SALT
    override_hash = hashlib.sha256(combined.encode()).hexdigest()

    print("\nâš ï¸ SKOPIUJ PONIÅ»SZÄ„ LINIÄ˜ DO PLIKU core/config.py:")
    print("-" * 60)
    print(f'SECURITY_OVERRIDE_HASH = "{override_hash}"')
    print("-" * 60)

if __name__ == "__main__":
    fix_users_db()
    fix_config_hash()

==================================================
FILE: scan_project.py
==================================================
import os

# Nazwa pliku wynikowego
OUTPUT_FILE = "redline_scan.txt"

# Czego NIE chcemy skanowaÄ‡ (Å›mieci)
IGNORE_DIRS = {
    'node_modules', '.git', '__pycache__', 'venv', '.venv', 'env',
    'build', 'dist', '.vscode', '.idea'
}
# Jakie pliki nas interesujÄ… (kod)
INCLUDE_EXT = {'.py', '.js', '.jsx', '.json', '.css', '.html', '.md'}

def scan_project():
    root_dir = os.getcwd()

    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(f"=== REDLINE PROJECT SCAN ===\n")
        f.write(f"Root: {root_dir}\n\n")

        # 1. Rysujemy strukturÄ™ folderÃ³w
        f.write("=== FILE STRUCTURE ===\n")
        for root, dirs, files in os.walk(root_dir):
            # Filtrowanie folderÃ³w
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]

            level = root.replace(root_dir, '').count(os.sep)
            indent = ' ' * 4 * (level)
            f.write(f"{indent}[{os.path.basename(root)}/]\n")
            subindent = ' ' * 4 * (level + 1)
            for file in files:
                f.write(f"{subindent}{file}\n")

        f.write("\n\n=== FILE CONTENTS ===\n")

        # 2. Zgrywamy treÅ›Ä‡ plikÃ³w kodu
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]

            for file in files:
                ext = os.path.splitext(file)[1].lower()
                if ext in INCLUDE_EXT and file != "package-lock.json" and file != OUTPUT_FILE:
                    path = os.path.join(root, file)
                    rel_path = os.path.relpath(path, root_dir)

                    f.write(f"\n\n{'='*50}\n")
                    f.write(f"FILE: {rel_path}\n")
                    f.write(f"{'='*50}\n")

                    try:
                        with open(path, 'r', encoding='utf-8') as source:
                            content = source.read()
                            # JeÅ›li plik jest ogromny (np. baza danych json), utnij go
                            if len(content) > 50000:
                                f.write("[CONTENT TOO LARGE - SKIPPED]\n")
                            else:
                                f.write(content)
                    except Exception as e:
                        f.write(f"[ERROR READING FILE: {e}]\n")

    print(f"âœ… Gotowe! Utworzono plik: {OUTPUT_FILE}")
    print("WrzuÄ‡ ten plik na czat.")

if __name__ == "__main__":
    scan_project()

==================================================
FILE: archive\streamlit_ui\app.py
==================================================
import streamlit as st

# =====================================================
# 1. PAGE CONFIG (MUSI BYÄ† PIERWSZE)
# =====================================================
st.set_page_config(
    page_title="REDLINE V68",
    layout="wide",
    initial_sidebar_state="collapsed",
)

# =====================================================
# 2. CORE IMPORTS
# =====================================================
from core.bootstrap import init_session, session_watchdog
from ui.styles import load_styles
from ui.auth import render_auth
from ui.dashboard import render_dashboard
from ui.hud import render_hud
from ui.admin import render_admin
from ui.wallet import render_wallet
from ui.scanner_view import render_scanner_view
from ui.training_view import render_training_view

# =====================================================
# 3. INIT SESSION
# =====================================================
init_session()
session_watchdog()

# =====================================================
# 4. LOAD STYLES
# =====================================================
load_styles(
    mode=st.session_state.get("ui_mode", "ops"),
    system_name="REDLINE V68",
    system_tagline="PRIVATE TRADING & RISK TERMINAL",
)

# =====================================================
# 5. GLOBAL EVENT SYSTEM (JS â€“ INLINE, BEZ alert())
# =====================================================
st.components.v1.html(
    """
    <script>
    console.log("EVENT SYSTEM INITIALIZING");

    const ws = new WebSocket("ws://127.0.0.1:8002/ws/events?scope=OPS");

    ws.onopen = () => {
        console.log("EVENT WS CONNECTED");
    };

    ws.onmessage = (e) => {
        const ev = JSON.parse(e.data);
        console.log("EVENT RECEIVED:", ev);

        let container = document.getElementById("event-overlay");
        if (!container) {
            container = document.createElement("div");
            container.id = "event-overlay";
            container.style.position = "fixed";
            container.style.top = "80px";
            container.style.right = "20px";
            container.style.zIndex = "9999";
            container.style.display = "flex";
            container.style.flexDirection = "column";
            container.style.gap = "10px";
            document.body.appendChild(container);
        }

        const card = document.createElement("div");
        card.style.background = "rgba(0,0,0,0.85)";
        card.style.color = "#e5e7eb";
        card.style.border = "1px solid #1f2937";
        card.style.borderRadius = "8px";
        card.style.padding = "10px 14px";
        card.style.fontSize = "12px";
        card.style.minWidth = "260px";
        card.style.boxShadow = "0 6px 18px rgba(0,0,0,0.45)";
        card.style.opacity = "0";
        card.style.transform = "translateY(-6px)";
        card.style.transition = "all 0.25s ease-out";

        if (ev.level === "warning") card.style.borderColor = "#f59e0b";
        if (ev.level === "success") card.style.borderColor = "#10b981";
        if (ev.level === "error") card.style.borderColor = "#ef4444";

        card.innerHTML = `
            <div style="font-weight:600; letter-spacing:1px;">${ev.type}</div>
            <div style="opacity:0.85; margin-top:4px;">${ev.message}</div>
        `;

        container.appendChild(card);

        requestAnimationFrame(() => {
            card.style.opacity = "1";
            card.style.transform = "translateY(0)";
        });

        setTimeout(() => {
            card.style.opacity = "0";
            card.style.transform = "translateY(-6px)";
            setTimeout(() => card.remove(), 300);
        }, 5000);
    };

    ws.onerror = (e) => {
        console.error("EVENT WS ERROR", e);
    };

    ws.onclose = () => {
        console.warn("EVENT WS CLOSED");
    };
    </script>
    """,
    height=0,
)

# =====================================================
# 6. AUTH GATE
# =====================================================
if not st.session_state["sys"].get("auth", False):
    render_auth()

else:
    # =================================================
    # HUD (TOP BAR)
    # =================================================
    render_hud()

    # =================================================
    # MAIN NAVIGATION
    # =================================================
    tabs = st.tabs(
        [
            " Dashboard",
            " Wallet",
            " Scanner",
            " Training",
            " System",
        ]
    )

    with tabs[0]:
        render_dashboard()

    with tabs[1]:
        render_wallet()

    with tabs[2]:
        render_scanner_view()

    with tabs[3]:
        render_training_view()

    with tabs[4]:
        render_admin()

==================================================
FILE: archive\streamlit_ui\ui\admin.py
==================================================
import streamlit as st
import pandas as pd
from security.user_manager import UserManager

def render_admin():
    if st.session_state['sys']['role'] != "ROOT":
        st.error("ACCESS DENIED")
        return

    st.markdown("##### ADMIN PANEL")
    db = UserManager.load_db()

    st.markdown("###### REQUESTS")
    for u in list(db.get('pending', {}).keys()):
        c1, c2, c3 = st.columns([3,1,1])
        c1.code(u)
        if c2.button("YES", key=f"y_{u}"): UserManager.approve_user(u, "TRADER"); st.rerun()
        if c3.button("NO", key=f"n_{u}"): UserManager.reject_user(u); st.rerun()

    st.markdown("---")
    st.markdown("###### ACTIVE USERS")
    if db['active']:
        st.dataframe(pd.DataFrame(db['active']).T)

==================================================
FILE: archive\streamlit_ui\ui\auth.py
==================================================
import streamlit as st
import time

from core.security import HardwareSecurity
from security.user_manager import UserManager

def render_auth():
    """
    REDLINE AUTH GATE
    Calm, centered, premium security login
    """

    # =====================================================
    # INIT SESSION STATE
    # =====================================================
    if "sys" not in st.session_state:
        st.session_state["sys"] = {
            "auth": False,
            "role": None,
            "user": None,
        }

    # =====================================================
    # AUTH-SPECIFIC CSS (CALM, NO NEON, NO WHITE)
    # =====================================================
    st.markdown(
        """
        <style>
        /* Center auth vertically */
        .block-container {
            padding-top: 4rem;
            padding-bottom: 6rem;
        }

        /* Inputs â€“ dark, calm */
        .stTextInput input {
            background-color: #0b0f19 !important;
            color: #d1d5db !important;
            border: 1px solid #1f2937 !important;
            border-radius: 8px !important;
            padding: 10px 12px !important;
            font-size: 13px !important;
        }

        .stTextInput input:focus {
            border-color: #7aa2f7 !important;
            box-shadow: none !important;
        }

        /* Buttons */
        .stButton button {
            background: #0b0f19;
            border: 1px solid #1f2937;
            color: #d1d5db;
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
        }

        .stButton button:hover {
            border-color: #7aa2f7;
            color: #7aa2f7;
        }

        /* Tabs â€“ minimal */
        div[data-baseweb="tab-list"] {
            justify-content: center;
            gap: 18px;
        }

        div[data-baseweb="tab"] {
            font-size: 12px;
            opacity: 0.6;
        }

        div[data-baseweb="tab"][aria-selected="true"] {
            opacity: 1;
            border-bottom: 2px solid #7aa2f7;
        }

        /* Subtle system text */
        .sys-text {
            font-size: 11px;
            color: #9ca3af;
            line-height: 1.4;
        }
        </style>
        """,
        unsafe_allow_html=True,
    )

    # =====================================================
    # CENTERED LAYOUT
    # =====================================================
    _, center, _ = st.columns([1, 1.6, 1])

    with center:
        # =================================================
        # HEADER
        # =================================================
        st.markdown(
            """
            <div style="text-align:center; margin-bottom:24px;">
                <div style="font-size:32px; letter-spacing:4px; color:#7aa2f7;">
                    REDLINE
                </div>
                <div style="font-size:11px; color:#9ca3af; letter-spacing:2px;">
                    SECURE TRADING TERMINAL
                </div>
            </div>
            """,
            unsafe_allow_html=True,
        )

        # =================================================
        # SYSTEM STATUS (SUBTLE)
        # =================================================
        st.markdown(
            """
            <div class="sys-text" style="margin-bottom:18px;">
                Secure channel initialized<br>
                Cipher handshake verified<br>
                User database online
            </div>
            """,
            unsafe_allow_html=True,
        )

        # =================================================
        # AUTH TABS
        # =================================================
        tab_login, tab_request = st.tabs(["LOGIN", "REQUEST ACCESS"])

        # =================================================
        # LOGIN TAB
        # =================================================
        with tab_login:
            # --- HARDWARE KEY (SUBTLE) ---
            try:
                has_key, drive = HardwareSecurity.scan_for_key()
                if has_key:
                    st.caption(f"Hardware key detected ({drive})")
                    if st.button("Quick Auth via Hardware Key", use_container_width=True):
                        if HardwareSecurity.verify_key_signature(drive):
                            st.session_state["sys"].update(
                                {"auth": True, "role": "ROOT", "user": "hardware"}
                            )
                            time.sleep(0.3)
                            st.rerun()
            except Exception:
                pass

            # --- CREDENTIAL FORM ---
            with st.form("auth_login"):
                user = st.text_input("User")
                passwd = st.text_input("Access Token", type="password")

                if st.form_submit_button("Initiate Uplink", use_container_width=True):
                    role = UserManager.verify_login(user, passwd)
                    if role:
                        st.session_state["sys"].update(
                            {"auth": True, "role": role, "user": user}
                        )
                        st.success("Access granted")
                        time.sleep(0.4)
                        st.rerun()
                    else:
                        st.warning("Invalid credentials")

        # =================================================
        # REQUEST ACCESS TAB
        # =================================================
        with tab_request:
            st.caption("Access requests require administrator approval.")

            with st.form("request_access"):
                new_user = st.text_input("Desired username")
                new_pass = st.text_input("Desired password", type="password")
                contact = st.text_input("Contact (email / telegram)")

                if st.form_submit_button("Submit Request", use_container_width=True):
                    if len(new_user) < 3 or len(new_pass) < 5:
                        st.warning("Username or password too short")
                    else:
                        ok, msg = UserManager.request_account(
                            new_user, new_pass, contact
                        )
                        if ok:
                            st.success("Request submitted")
                            st.caption("Await administrator approval")
                        else:
                            st.warning(msg)

        # =================================================
        # FOOTER (VERY SUBTLE)
        # =================================================
        try:
            hwid = HardwareSecurity.get_hardware_id()
            hwid_text = f"HWID {hwid}"
        except Exception:
            hwid_text = "HWID unavailable"

        st.markdown(
            f"""
            <div style="text-align:center; margin-top:28px;">
                <div class="sys-text">
                    {hwid_text}<br>
                    Unauthorized access attempts are logged
                </div>
            </div>
            """,
            unsafe_allow_html=True,
        )

==================================================
FILE: archive\streamlit_ui\ui\dashboard.py
==================================================
import streamlit as st
import time
import plotly.graph_objects as go

# =====================================================
# CORE
# =====================================================
from core.logger import log_event

# DATA & ML
from data.feed import DataFeed
from ml.brain import DeepBrain
from ml.regime import MarketRegime
from ml.knowledge import KnowledgeBase

# TRADING LOGIC
from trading.decision import DecisionEngine
from trading.execution import ExecutionEngine
from trading.analytics import TradeAnalytics

# =====================================================
# UI HELPERS
# =====================================================
def card_open(title: str = None):
    st.markdown(
        f"""
        <div style="
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 10px;
            padding: 18px;
            margin-bottom: 18px;
        ">
        {f"<div style='font-size:13px; color:var(--muted); margin-bottom:8px; letter-spacing:1px'>{title}</div>" if title else ""}
        """,
        unsafe_allow_html=True,
    )

def card_close():
    st.markdown("</div>", unsafe_allow_html=True)

# =====================================================
# MAIN DASHBOARD
# =====================================================
def render_dashboard():
    """
    PREMIUM DASHBOARD
    - OPS MODE (ADMIN / ROOT)
    - INVESTOR MODE (GUEST / USER)
    - REPORT LOOK (read-only)
    """

    sys = st.session_state.get("sys", {})
    role = sys.get("role", "GUEST")
    user = sys.get("user", "viewer")

    is_ops = role in {"ADMIN", "ROOT"}
    is_investor = not is_ops

    decision_engine = DecisionEngine(mode="PAPER")
    executor = ExecutionEngine(mode="PAPER")

    # =====================================================
    # ðŸ”Œ JS EVENT SYSTEM (ROLE-BASED)
    # =====================================================
    if is_ops:
        st.components.v1.html(
            """
            <script src="/static/event_renderer.js"></script>
            <script src="/static/events_ops.js"></script>
            """,
            height=0,
        )
    else:
        st.components.v1.html(
            """
            <script src="/static/event_renderer.js"></script>
            <script src="/static/events_investor.js"></script>
            """,
            height=0,
        )

    # =====================================================
    # HUD â€” SYSTEM PERFORMANCE
    # =====================================================
    card_open("SYSTEM PERFORMANCE (PAPER)")

    stats = TradeAnalytics.generate_report()

    hud = st.columns(4)
    hud[0].metric("Win Rate", f"{stats['win_rate']}%", f"{stats['total_trades']} trades")
    hud[1].metric("Profit Factor", f"{stats['profit_factor']:.2f}")
    hud[2].metric("Expectancy (EV)", f"${stats['expectancy']:.2f}")
    hud[3].metric("Net PnL", f"${stats['net_profit']:.2f}", f"DD {stats['max_drawdown']:.2f}")

    card_close()

    # =====================================================
    # INVESTOR MODE â€” REPORT VIEW
    # =====================================================
    if is_investor:
        card_open("INVESTOR REPORT")

        st.caption("Read-only performance overview")

        st.markdown(
            f"""
            <div style="font-size:14px; margin-bottom:12px;">
                Strategy Status: <b>ACTIVE (Paper)</b><br>
                Risk Profile: <b>Conservative / Systematic</b><br>
                Last Trade: <b>{stats.get("last_trade", "N/A")}</b>
            </div>
            """,
            unsafe_allow_html=True,
        )

        card_close()
        return  # INVESTOR NIE WIDZI OPS

    # =====================================================
    # OPS MODE â€” ACTIVE OPERATIONS
    # =====================================================
    left, right = st.columns([1.2, 2.2], gap="large")

    # =============================
    # LEFT â€” OPS CONTROL
    # =============================
    with left:
        card_open("NEURAL OPS")

        symbol = st.selectbox(
            "Market",
            ["BTC/USDT", "ETH/USDT", "SOL/USDT", "BNB/USDT", "XRP/USDT"],
        )
        tf = st.selectbox("Timeframe", ["15m", "1h", "4h"], index=1)

        if st.button("RUN MARKET SCAN", use_container_width=True):

            brain = DeepBrain()

            with st.status("Running inference pipeline...", expanded=True):
                df = DataFeed.get_market_data(symbol, tf)

                if df.empty:
                    st.warning("Market data unavailable.")
                    card_close()
                    return

                ai_price, conf, signal = brain.predict(df)
                mqs, regime = MarketRegime.analyze(df)

            price = df["close"].iloc[-1]
            upside = (ai_price - price) / price * 100
            ev = (upside * conf) - abs(upside) * (1 - conf) * 0.5

            card_open("AI SIGNAL")

            st.markdown(
                f"""
                <div style="text-align:center;">
                    <div style="font-size:26px; font-weight:600;">{signal}</div>
                    <div style="font-size:12px; opacity:0.8;">
                        CONF {conf*100:.1f}% | EV {ev:.2f} | MQS {mqs}
                    </div>
                </div>
                """,
                unsafe_allow_html=True,
            )

            card_close()

            card_open("RISK GATE")

            candidate = {
                "symbol": symbol,
                "signal": signal,
                "conf": conf,
                "mqs": mqs,
                "current_price": price,
            }

            approved, reason, size = decision_engine.evaluate_entry(candidate)

            if approved:
                st.info(f"Approved. Position size ${size:.2f}")

                if st.button(f"EXECUTE {signal}", use_container_width=True):
                    res = executor.execute_order(symbol, "BUY", size)
                    if res.get("status") == "FILLED":
                        st.success(f"Filled @ {res.get('avg_price'):.2f}")
                        log_event(f"MANUAL EXEC {symbol}", "TRADE")
                        time.sleep(0.6)
                        st.rerun()
                    else:
                        st.warning(res.get("reason", "Execution issue"))
            else:
                st.warning(f"Blocked: {reason}")

            card_close()

    # =============================
    # RIGHT â€” MARKET MAP
    # =============================
    with right:
        card_open("MARKET MAP")

        df_chart = DataFeed.get_market_data(symbol, tf)

        if not df_chart.empty:
            fig = go.Figure(
                data=[
                    go.Candlestick(
                        x=df_chart["time"],
                        open=df_chart["open"],
                        high=df_chart["high"],
                        low=df_chart["low"],
                        close=df_chart["close"],
                        increasing_line_color="#7aa2f7",
                        decreasing_line_color="#9ca3af",
                    )
                ]
            )

            fig.update_layout(
                height=560,
                template="plotly_dark",
                margin=dict(t=20, b=20, l=0, r=0),
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="rgba(0,0,0,0)",
                xaxis=dict(rangeslider=dict(visible=False)),
            )

            st.plotly_chart(fig, use_container_width=True)

        card_close()

    # =====================================================
    # REPORT DISCLAIMER
    # =====================================================
    card_open("REPORT SUMMARY")

    st.markdown(
        """
        <div style="font-size:12px; opacity:0.75;">
            This system operates under predefined risk rules.
            Historical performance does not guarantee future results.
        </div>
        """,
        unsafe_allow_html=True,
    )

    card_close()

==================================================
FILE: archive\streamlit_ui\ui\hud.py
==================================================
import streamlit as st

def render_hud():
    st.components.v1.html(
        """
        <div id="hud-bar" style="
            display:flex;
            align-items:center;
            gap:18px;
            padding:8px 16px;
            margin-bottom:16px;
            border:1px solid var(--accent,#1f2937);
            border-radius:10px;
            background:rgba(255,255,255,0.03);
            font-size:12px;
            color:var(--text,#d1d5db);
        ">
            <span>CONNECTING HUDâ€¦</span>
        </div>

        <script>
        const hud = document.getElementById("hud-bar");
        const ws = new WebSocket("ws://127.0.0.1:8001/ws/hud");

        function color(v){
            if(v >= 80) return "#7f1d1d";
            if(v >= 60) return "#92400e";
            return "var(--text,#d1d5db)";
        }

        ws.onmessage = (e) => {
            const d = JSON.parse(e.data);
            const isOps = ["ADMIN","ROOT"].includes(d.role);

            let html = "";

            if(isOps){
                html += `<span>NODE <b>${d.node}</b></span>`;
                html += `<span>USER <b>${d.user}</b></span>`;
                html += `<span style="color:${color(d.cpu)}">CPU <b>${d.cpu.toFixed(1)}%</b></span>`;
                html += `<span style="color:${color(d.mem)}">MEM <b>${d.mem.toFixed(1)}%</b></span>`;
            }

            html += `<span>FUNDS <b>$${Number(d.funds).toLocaleString()}</b></span>`;
            html += `<span>TIME <b>${d.time}</b></span>`;

            hud.innerHTML = html;
        };

        ws.onerror = () => {
            hud.innerHTML = "<span style='color:#92400e'>HUD ERROR</span>";
        };

        ws.onclose = () => {
            hud.innerHTML = "<span style='color:#92400e'>HUD DISCONNECTED</span>";
        };
        </script>
        """,
        height=56,
    )

==================================================
FILE: archive\streamlit_ui\ui\scanner_view.py
==================================================
import streamlit as st
import pandas as pd
import plotly.express as px
from core.auto_rotator import AutoRotator
from core.config import THEMES

def render_scanner_view():
    """Widok Skanera Rynku V5-PRO"""
    theme = THEMES[st.session_state['sys'].get('theme', 'MATRIX')]

    st.markdown("###  DEEP FIELD SCANNER V5")
    st.caption("Pro-Grade Screening: HTF Trend + Regime Filter + Risk-Adjusted Scoring")

    # Pasek narzÄ™dzi
    c1, c2, c3 = st.columns([1, 1, 2])

    with c1:
        timeframe = st.selectbox("TIMEFRAME (LTF)", ["15m", "1h", "4h"], index=1, key="scan_tf")

    with c2:
        st.write("")
        st.write("")
        # Przycisk uruchamia skanowanie
        run_btn = st.button(" SCAN TOP 50 LIQUID PAIRS", use_container_width=True)

    # Logika Skanowania
    if run_btn:
        with st.status("RUNNING QUANTUM SCAN PROTOCOL...", expanded=True):
            st.write(" Fetching Market Data & Checking 4H HTF Trends...")
            st.write(" Calculating Market Regime (MQS) & Filtering Chop...")
            st.write(" DeepBrain Inference (Threshold > 60%)...")

            # Uruchomienie skanera
            result_df = AutoRotator.run_scan(timeframe)
            st.session_state['scan_result'] = result_df

            if not result_df.empty:
                st.success(f"SCAN COMPLETE. Found {len(result_df)} opportunities.")
            else:
                st.warning("NO OPPORTUNITIES FOUND (Market might be choppy).")

    # WyÅ›wietlanie wynikÃ³w
    if 'scan_result' in st.session_state and not st.session_state['scan_result'].empty:
        df = st.session_state['scan_result']

        # Top Picks
        top_picks = df.head(10)

        st.markdown(f"#### ELITE SIGNALS (Top {len(top_picks)})")

        # Formatowanie tabeli
        # Dodajemy kolory do trendu HTF
        def highlight_htf(val):
            color = theme['p'] if val == "BULLISH" else ('red' if val == "BEARISH" else 'grey')
            return f'color: {color}; font-weight: bold'

        styled_df = top_picks[['symbol', 'signal', 'htf_trend', 'mqs', 'conf', 'growth_%', 'score']].style.applymap(
            highlight_htf, subset=['htf_trend']
        ).format({
            "conf": "{:.2f}",
            "growth_%": "{:+.2f}%",
            "score": "{:.1f}",
            "mqs": "{:.0f}"
        })

        st.dataframe(styled_df, use_container_width=True)

        # Wizualizacja V5
        c_chart1, c_chart2 = st.columns(2)

        with c_chart1:
            # Wykres PotencjaÅ‚u vs Ryzyka
            fig = px.scatter(
                top_picks, x='mqs', y='score',
                size='conf', color='htf_trend', hover_name='symbol',
                title="Market Quality vs AI Score",
                color_discrete_map={"BULLISH": theme['p'], "BEARISH": "red", "NEUTRAL": "grey"}
            )
            fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', font_color='white')
            st.plotly_chart(fig, use_container_width=True)

        with c_chart2:
            # Ranking sÅ‚upkowy
            fig2 = px.bar(
                top_picks, x='symbol', y='score',
                color='signal',
                title="Final Edge Score (Risk-Adjusted)",
                color_discrete_map={"BUY": theme['p'], "SELL": "red"}
            )
            fig2.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', font_color='white')
            st.plotly_chart(fig2, use_container_width=True)

    elif 'scan_result' in st.session_state:
        st.info("System filtered out all assets. Current market conditions do not meet 'PRO' entry criteria.")

==================================================
FILE: archive\streamlit_ui\ui\shared.py
==================================================
import streamlit as st
import psutil, os
from datetime import datetime
from core.config import THEMES
from trading.wallet import WalletManager

def render_hud():
    """Displays top status HUD in hacker terminal style."""
    theme = THEMES[st.session_state['sys'].get('theme', 'MATRIX')]
    user = st.session_state['sys'].get('user', 'anon')
    cpu = psutil.cpu_percent()
    ram = psutil.virtual_memory().percent
    wallet = WalletManager.get_balance()
    pid = os.getpid()
    clock = datetime.now().strftime("%H:%M:%S")

    st.markdown(f"""
    <div class="hud-bar">
        <div>NODE: <span style="color:{theme['p']}">REDLINE_V68</span></div>
        <div>USER: <span style="color:#fff">{user}</span> (PID {pid})</div>
        <div>CPU: {cpu}% | MEM: {ram}%</div>
        <div>FUNDS: <span style="color:{theme['p']}">${wallet:,.2f}</span></div>
        <div>TIME: {clock}</div>
    </div>
    """, unsafe_allow_html=True)

==================================================
FILE: archive\streamlit_ui\ui\styles.py
==================================================
import streamlit as st

@st.cache_data
def _render_css(css: str):
    st.markdown(css, unsafe_allow_html=True)

def load_styles(
    mode: str = "ops",
    system_name: str = "REDLINE V68",
    system_tagline: str = "PRIVATE TRADING & RISK TERMINAL",
):
    mode = mode.lower()
    if mode not in {"ops", "user"}:
        raise ValueError("Invalid UI mode")

    # ================= COLORS =================
    if mode == "user":
        bg = "#0e1117"
        panel = "#121826"
        text = "#e5e7eb"
        muted = "#9ca3af"
        prim = "#d4b46a"
        accent = "#1f2937"
        alert = "#92400e"
        error = "#7f1d1d"
        glow = "none"
    else:
        bg = "#05070c"
        panel = "#0b0f19"
        text = "#d1d5db"
        muted = "#6b7280"
        prim = "#7aa2f7"
        accent = "#111827"
        alert = "#92400e"
        error = "#7f1d1d"
        glow = "0 0 12px rgba(122,162,247,0.15)"

    css = f"""
    <style>
    :root {{
        --bg: {bg};
        --panel: {panel};
        --text: {text};
        --muted: {muted};
        --prim: {prim};
        --accent: {accent};
        --alert: {alert};
        --error: {error};
    }}

    html, body, [data-testid="stAppViewContainer"] {{
        background: var(--bg) !important;
        color: var(--text);
        font-family: Inter, sans-serif;
    }}

    [data-testid="stMainBlockContainer"] {{
        max-width: 1400px;
        margin: auto;
        background: var(--panel);
        padding: 28px;
        border-radius: 12px;
        box-shadow: {glow};
    }}

    .brand-bar {{
        text-align: center;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--accent);
    }}

    .brand-title {{
        color: var(--prim);
        font-size: 18px;
        letter-spacing: 2px;
    }}

    .brand-tagline {{
        color: var(--muted);
        font-size: 11px;
        letter-spacing: 1.5px;
    }}

    /* ================= HUD ================= */
    .hud-bar {{
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 18px;
        padding: 8px 14px;
        margin-bottom: 18px;
        background: rgba(255,255,255,0.03);
        border: 1px solid var(--accent);
        border-radius: 10px;
        font-size: 12px;
        color: var(--muted);
    }}

    .hud-item {{
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
    }}

    .hud-ok {{ color: var(--text); }}
    .hud-warn {{ color: var(--alert); }}
    .hud-crit {{ color: var(--error); }}

    .hud-icon {{
        width: 12px;
        height: 12px;
        opacity: 0.7;
    }}

    #MainMenu, header, footer {{
        visibility: hidden;
    }}
    </style>

    <div class="brand-bar">
        <div class="brand-title">{system_name}</div>
        <div class="brand-tagline">{system_tagline}</div>
    </div>
    """

    _render_css(css)

==================================================
FILE: archive\streamlit_ui\ui\training_view.py
==================================================
import streamlit as st
import pandas as pd
import time
from core.config import THEMES
from ml.brain import DeepBrain
from ml.knowledge import KnowledgeBase
from data.feed import DataFeed

def render_training_view():
    """
    WIDOK TRENINGOWY (AI LAB).
    Pozwala douczaÄ‡ model na bÅ‚Ä™dach i zarzÄ…dzaÄ‡ bazÄ… wiedzy.
    """
    # Pobieramy motyw z sesji (bezpiecznie)
    theme_name = st.session_state['sys'].get('theme', 'MATRIX')
    theme = THEMES[theme_name]

    st.markdown(f"### NEURAL LABS")
    st.caption("Reinforcement Learning & Pattern Correction")

    # Linia, ktÃ³ra powodowaÅ‚a bÅ‚Ä…d (teraz bezpieczna dziÄ™ki poprawionemu config.py)
    st.markdown(f"<hr style='border-color:{theme['s']}'>", unsafe_allow_html=True)

    c1, c2 = st.columns([1, 2])

    with c1:
        st.info("MANUAL OVERRIDE TRAINING")
        symbol = st.text_input("SYMBOL", "BTC/USDT")

        if st.button("FETCH & ANALYZE"):
            df = DataFeed.get_market_data(symbol, "1h", limit=100)
            if not df.empty:
                st.session_state['train_df'] = df
                st.success("DATA LOADED")
            else:
                st.error("NO DATA")

    with c2:
        if 'train_df' in st.session_state:
            df = st.session_state['train_df']

            # Brain Inference
            brain = DeepBrain()
            price, conf, signal = brain.predict(df)

            st.markdown(f"#### AI PREDICTION: <span style='color:{theme['p']}'>{signal}</span> ({conf*100:.1f}%)", unsafe_allow_html=True)
            st.line_chart(df['close'])

            st.write("Was this prediction correct?")

            b1, b2 = st.columns(2)
            if b1.button(" YES (REWARD)"):
                snap = {"close": df['close'].iloc[-1], "rsi": 50} # Uproszczony snapshot
                KnowledgeBase.save_pattern("OPERATOR", snap, 1.0)
                st.success("Model Rewarded (+1.0)")

            if b2.button(" NO (PUNISH)"):
                snap = {"close": df['close'].iloc[-1], "rsi": 50}
                KnowledgeBase.save_pattern("OPERATOR", snap, -1.0)
                st.error("Model Punished (-1.0)")

==================================================
FILE: archive\streamlit_ui\ui\wallet.py
==================================================
import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime

# CORE & TRADING IMPORTS
from core.config import THEMES
from trading.wallet import WalletManager
from trading.execution import ExecutionEngine # <-- Tu byÅ‚a stara nazwa TradeExecutor

def render_wallet():
    """
    WIDOK PORTFELA (BANKING).
    Wersja V2: Zintegrowana z WalletManager i ExecutionEngine.
    """
    theme = THEMES[st.session_state['sys'].get('theme', 'MATRIX')]

    # Pobieramy dane z portfela
    wallet = WalletManager.get_wallet_data()
    balance = wallet.get('balance', 0.0)
    assets = wallet.get('assets', [])
    history = wallet.get('history', [])

    # NagÅ‚Ã³wek
    c1, c2 = st.columns([3, 1])
    with c1:
        st.markdown(f"## ðŸ’³ WALLET OPS")
        st.caption("Capital Allocation & Asset Tracking")
    with c2:
        st.metric("AVAILABLE CASH", f"${balance:,.2f}")

    st.divider()

    # --- SEKCJA 1: AKTYWA (ASSETS) ---
    st.markdown("### ðŸ›ï¸ ACTIVE HOLDINGS")

    if assets:
        # Konwersja do DataFrame dla Å‚adnego wyÅ›wietlania
        df_assets = pd.DataFrame(assets)

        # Obliczamy bieÅ¼Ä…cÄ… wartoÅ›Ä‡ (symulacja, bo w assets mamy cenÄ™ wejÅ›cia)
        # W wersji PRO tutaj pobieralibyÅ›my aktualnÄ… cenÄ™ z DataFeed,
        # ale na potrzeby widoku portfela wystarczy podglÄ…d wejÅ›cia.

        # Formatowanie tabeli
        display_df = df_assets.copy()

        # JeÅ›li mamy kolumny z datami w ISO, sformatujmy je
        if 'ts' in display_df.columns:
            display_df['entry_time'] = display_df['ts'] # Uproszczenie

        # WybÃ³r kolumn do wyÅ›wietlenia
        cols_to_show = ['sym', 'amt', 'entry', 'cost', 'ts']
        # Filtrujemy tylko te, ktÃ³re istniejÄ…
        final_cols = [c for c in cols_to_show if c in display_df.columns]

        st.dataframe(
            display_df[final_cols].style.format({
                "entry": "${:.2f}",
                "cost": "${:.2f}",
                "amt": "{:.4f}"
            }),
            use_container_width=True,
            hide_index=True
        )

        # Wykres koÅ‚owy alokacji
        if len(assets) > 0:
            fig = px.pie(df_assets, values='cost', names='sym', title='Exposure Allocation',
                         color_discrete_sequence=[theme['p'], '#444', '#666'])
            fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', font_color='white')
            st.plotly_chart(fig, use_container_width=True)

    else:
        st.info("No active positions. Capital is 100% liquid.")

    st.divider()

    # --- SEKCJA 2: HISTORIA (LOGI) ---
    st.markdown("### ðŸ“œ TRANSACTION LEDGER")

    if history:
        # Odwracamy kolejnoÅ›Ä‡ (najnowsze na gÃ³rze)
        df_hist = pd.DataFrame(history).iloc[::-1]

        st.dataframe(
            df_hist,
            use_container_width=True,
            hide_index=True
        )
    else:
        st.caption("No transaction history recorded yet.")

    # --- SEKCJA 3: DEBUG / MANUAL ACTIONS ---
    with st.expander("ðŸ› ï¸ TELLER OPERATIONS (Manual Deposit/Withdraw)", expanded=False):
        c_dep1, c_dep2 = st.columns(2)
        amount = c_dep1.number_input("Amount ($)", min_value=10.0, step=100.0, value=1000.0)

        if c_dep2.button("DEPOSIT FUNDS"):
            new_bal = balance + amount
            wallet['balance'] = round(new_bal, 2)

            # Log
            if 'history' not in wallet: wallet['history'] = []
            wallet['history'].append({
                "date": datetime.now().strftime('%Y-%m-%d'),
                "action": "DEPOSIT",
                "desc": f"MANUAL TRANSFER +${amount}",
                "pnl_val": 0
            })

            WalletManager.save_wallet_data(wallet)
            st.success(f"Deposited ${amount}. New Balance: ${new_bal:.2f}")
            st.rerun()

        if c_dep2.button("WITHDRAW FUNDS"):
            if balance >= amount:
                new_bal = balance - amount
                wallet['balance'] = round(new_bal, 2)
                 # Log
                if 'history' not in wallet: wallet['history'] = []
                wallet['history'].append({
                    "date": datetime.now().strftime('%Y-%m-%d'),
                    "action": "WITHDRAW",
                    "desc": f"MANUAL TRANSFER -${amount}",
                    "pnl_val": 0
                })
                WalletManager.save_wallet_data(wallet)
                st.success(f"Withdrawn ${amount}. New Balance: ${new_bal:.2f}")
                st.rerun()
            else:
                st.error("Insufficient funds.")

==================================================
FILE: archive\streamlit_ui\ui\__init__.py
==================================================
from .auth import render_auth
from .dashboard import render_dashboard
from .wallet import render_wallet
from .admin import render_admin
from .shared import render_hud
from .styles import load_styles
from .training_view import render_training_view
from .scanner_view import render_scanner_view
from .hud import render_hud

==================================================
FILE: archive\streamlit_ui\ui\js\events_investor.js
==================================================
const wsInvestor = new WebSocket(
  "ws://127.0.0.1:8002/ws/events?scope=INVESTOR"
);

wsInvestor.onmessage = (e) => {
  const event = JSON.parse(e.data);
  if (window.renderEvent) {
    window.renderEvent(event);
  }
};

wsInvestor.onopen = () => {
  console.log("INVESTOR EVENT STREAM CONNECTED");
};

wsInvestor.onclose = () => {
  console.warn("INVESTOR EVENT STREAM DISCONNECTED");
};

==================================================
FILE: archive\streamlit_ui\ui\js\events_ops.js
==================================================
const wsOps = new WebSocket(
  "ws://127.0.0.1:8002/ws/events?scope=OPS"
);

wsOps.onmessage = (e) => {
  const event = JSON.parse(e.data);
  if (window.renderEvent) {
    window.renderEvent(event);
  }
};

wsOps.onopen = () => {
  console.log("OPS EVENT STREAM CONNECTED");
};

wsOps.onclose = () => {
  console.warn("OPS EVENT STREAM DISCONNECTED");
};

==================================================
FILE: archive\streamlit_ui\ui\js\event_renderer.js
==================================================
function renderEvent(event) {
  const containerId = "global-event-overlay";
  let container = document.getElementById(containerId);

  if (!container) {
    container = document.createElement("div");
    container.id = containerId;
    container.style.position = "fixed";
    container.style.top = "20px";
    container.style.right = "20px";
    container.style.zIndex = "9999";
    document.body.appendChild(container);
  }

  const card = document.createElement("div");
  card.style.marginBottom = "10px";
  card.style.padding = "10px 14px";
  card.style.borderRadius = "8px";
  card.style.fontSize = "12px";
  card.style.background = "rgba(0,0,0,0.85)";
  card.style.color = "#e5e7eb";
  card.style.border = "1px solid #1f2937";
  card.style.boxShadow = "0 4px 12px rgba(0,0,0,0.4)";

  if (event.level === "warning") card.style.borderColor = "#f59e0b";
  if (event.level === "success") card.style.borderColor = "#10b981";
  if (event.level === "error") card.style.borderColor = "#ef4444";

  card.innerHTML = `
    <div style="font-weight:600; letter-spacing:1px;">${event.type}</div>
    <div style="opacity:0.9; margin-top:4px;">${event.message}</div>
  `;

  container.appendChild(card);

  setTimeout(() => {
    card.remove();
  }, 5000);
}

window.renderEvent = renderEvent;

==================================================
FILE: assets\training_report.json
==================================================
{
    "timestamp": "2026-01-04T18:07:26.081222",
    "model_version": "DeepBrain V4.5",
    "timeframe": "1h",
    "epochs": 50,
    "device": "cpu",
    "assets": [],
    "errors": [
        {
            "asset": "BTC/USDT",
            "reason": "INSUFFICIENT_DATA"
        },
        {
            "asset": "ETH/USDT",
            "reason": "INSUFFICIENT_DATA"
        }
    ],
    "duration_sec": 13.18
}

==================================================
FILE: assets\users_db.json
==================================================
{
    "active": {
        "admin": {
            "hash": "240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9",
            "role": "ROOT",
            "contact": "sysadmin",
            "created": "2026-01-01"
        }
    },
    "pending": {}
}

==================================================
FILE: backend\ai_core.py
==================================================
# backend/ai_core.py
"""
REDLINE AI CORE â€” GEN 2
Stateful, Explainable, Auto-Trading Ready

ML logic lives in /ml
This file orchestrates decisions only.
"""

import time
import threading
from datetime import datetime, timedelta

from ml.scanner import MarketScanner
from ml.brain import DeepBrain
from ml.regime import MarketRegime

from trading.decision import DecisionEngine
from trading.execution import ExecutionEngine
from trading.wallet import WalletManager

from core.logger import log_event
from core.event_logger import EventLogger

class RedlineAICore:
    """
    Central AI Orchestrator (GEN-2)
    """

    def __init__(self, mode="PAPER", timeframe="1h"):
        self.mode = mode
        self.timeframe = timeframe

        # ML
        self.scanner = MarketScanner(timeframe=timeframe)
        self.brain = DeepBrain()

        # Trading
        self.decision = DecisionEngine(mode=mode)
        self.executor = ExecutionEngine(mode=mode)

        # ===== AI STATE =====
        self.state = {
            "mode": "SEMI",               # MANUAL | SEMI | AUTO
            "running": False,
            "last_cycle": None,
            "ai_score": 0.0,
            "cooldowns": {},              # symbol -> datetime
            "last_signals": {},           # symbol -> signal
            "errors": 0
        }

        log_event(f"AI CORE GEN-2 INIT [{mode} | {timeframe}]", "INFO")

    # =====================================================
    # PUBLIC CONTROL
    # =====================================================
    def set_mode(self, mode: str):
        if mode not in {"MANUAL", "SEMI", "AUTO"}:
            raise ValueError("Invalid AI mode")
        self.state["mode"] = mode
        log_event(f"AI MODE SET â†’ {mode}", "WARN")

    def get_state(self):
        wallet = WalletManager.get_wallet_data()
        return {
            **self.state,
            "balance": wallet.get("balance", 0.0),
            "positions": wallet.get("assets", []),
        }

    # =====================================================
    # MAIN AI CYCLE
    # =====================================================
    def run_once(self):
        """
        One full AI decision cycle.
        """
        self.state["last_cycle"] = datetime.utcnow().isoformat()
        log_event("AI CYCLE START", "INFO")

        try:
            df = self.scanner.scan()
            if df.empty:
                log_event("SCAN EMPTY", "WARN")
                return []

            results = []

            for _, row in df.head(5).iterrows():
                symbol = row["symbol"]

                # ===== COOLDOWN CHECK =====
                cd = self.state["cooldowns"].get(symbol)
                if cd and datetime.utcnow() < cd:
                    results.append({
                        "symbol": symbol,
                        "status": "COOLDOWN"
                    })
                    continue

                # ===== SIGNAL LOG =====
                signal_id = EventLogger.log_signal(
                    symbol=symbol,
                    tf=self.timeframe,
                    signal=row.get("signal"),
                    conf=row.get("confidence", 0),
                    mqs=row.get("mqs", 0),
                    htf_trend=row.get("htf_trend", "NEUTRAL"),
                    ev=row.get("ev", 0),
                )

                candidate = {
                    "symbol": symbol,
                    "signal": row.get("signal"),
                    "conf": row.get("confidence"),
                    "mqs": row.get("mqs"),
                    "current_price": row.get("price"),
                    "reasons": row.get("reasons", [])
                }

                # ===== DECISION =====
                approved, reason, size = self.decision.evaluate_entry(candidate)

                EventLogger.log_decision(
                    symbol=symbol,
                    signal=candidate["signal"],
                    approved=approved,
                    reason=reason,
                    size_usd=size,
                    signal_id=signal_id
                )

                if not approved:
                    results.append({
                        "symbol": symbol,
                        "status": "REJECTED",
                        "reason": reason
                    })
                    continue

                # ===== SEMI MODE =====
                if self.state["mode"] == "SEMI":
                    results.append({
                        "symbol": symbol,
                        "status": "APPROVED_WAITING",
                        "size": size
                    })
                    continue

                # ===== AUTO MODE =====
                if self.state["mode"] == "AUTO":
                    exec_res = self.executor.execute_order(
                        symbol=symbol,
                        side="BUY",
                        amount_usd=size,
                        signal_id=signal_id
                    )

                    if exec_res.get("status") == "FILLED":
                        EventLogger.log_execution(
                            symbol=symbol,
                            side="BUY",
                            entry_price=exec_res.get("avg_price"),
                            qty=exec_res.get("qty"),
                            cost=exec_res.get("cost"),
                            order_status="FILLED",
                            signal_id=signal_id
                        )

                        # cooldown 1 cycle
                        self.state["cooldowns"][symbol] = (
                            datetime.utcnow() + timedelta(minutes=30)
                        )

                    results.append(exec_res)

            log_event("AI CYCLE END", "INFO")
            return results

        except Exception as e:
            self.state["errors"] += 1
            log_event(f"AI CORE ERROR: {e}", "CRITICAL")
            return []

    # =====================================================
    # AUTO MODE LOOP
    # =====================================================
    def _auto_loop(self, interval_sec: int):
        log_event("AI AUTO LOOP STARTED", "WARN")
        self.state["running"] = True

        while self.state["running"]:
            self.run_once()
            time.sleep(interval_sec)

    def start_auto(self, interval_sec: int = 3600):
        if self.state["running"]:
            return
        self.set_mode("AUTO")
        thread = threading.Thread(
            target=self._auto_loop,
            args=(interval_sec,),
            daemon=True
        )
        thread.start()

    def stop_auto(self):
        self.state["running"] = False
        self.set_mode("SEMI")
        log_event("AI AUTO LOOP STOPPED", "WARN")

==================================================
FILE: backend\auth.py
==================================================

==================================================
FILE: backend\events_server.py
==================================================
import asyncio
import json
from datetime import datetime
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from urllib.parse import parse_qs

app = FastAPI()

# =====================================================
# EVENT SOURCE (DEMO, ALE PERSISTENT)
# =====================================================
async def event_loop(ws: WebSocket, scope: str):
    """
    Persistent event loop.
    - Nigdy siÄ™ nie koÅ„czy
    - WysyÅ‚a eventy lub heartbeat
    """

    counter = 0

    while True:
        try:
            # ===============================
            # DEMO EVENTY CO KILKA SEKUND
            # ===============================
            if counter % 5 == 0:
                if scope == "OPS":
                    event = {
                        "scope": "OPS",
                        "type": "SYSTEM",
                        "level": "info",
                        "message": "System running",
                        "ts": datetime.utcnow().isoformat(),
                    }
                else:
                    event = {
                        "scope": "INVESTOR",
                        "type": "STATUS",
                        "level": "info",
                        "message": "Portfolio stable",
                        "ts": datetime.utcnow().isoformat(),
                    }

                await ws.send_text(json.dumps(event))

            # ===============================
            # HEARTBEAT (KEEP-ALIVE)
            # ===============================
            heartbeat = {
                "scope": scope,
                "type": "HEARTBEAT",
                "level": "info",
                "message": "alive",
                "ts": datetime.utcnow().isoformat(),
            }

            await ws.send_text(json.dumps(heartbeat))

            counter += 1
            await asyncio.sleep(1)

        except WebSocketDisconnect:
            print(f"[EVENTS] Client disconnected ({scope})")
            break

        except Exception as e:
            print(f"[EVENTS] Error: {e}")
            await asyncio.sleep(1)

# =====================================================
# WEBSOCKET ENDPOINT
# =====================================================
@app.websocket("/ws/events")
async def events_ws(ws: WebSocket):
    params = parse_qs(ws.scope["query_string"].decode())
    scope = params.get("scope", ["OPS"])[0]

    if scope not in {"OPS", "INVESTOR"}:
        await ws.close(code=1008)
        return

    await ws.accept()
    print(f"[EVENTS] Client connected ({scope})")

    await event_loop(ws, scope)

==================================================
FILE: backend\hud_server.py
==================================================
import asyncio
import psutil
from datetime import datetime
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def get_metrics():
    return {
        "cpu": psutil.cpu_percent(interval=0.1),
        "mem": psutil.virtual_memory().percent,
        "time": datetime.now().strftime("%H:%M:%S"),
    }

@app.websocket("/ws/hud")
async def hud_ws(ws: WebSocket):
    await ws.accept()
    try:
        while True:
            payload = {
                **get_metrics(),
                # docelowo to weÅºmiemy z sesji / auth
                "node": "REDLINE_V68",
                "user": "admin",
                "role": "ADMIN",
                "funds": 1000.00,
            }
            await ws.send_json(payload)
            await asyncio.sleep(1)
    except WebSocketDisconnect:
        pass

==================================================
FILE: backend\main.py
==================================================
# backend/main.py
"""
REDLINE BACKEND â€” GEN 2
FastAPI entrypoint
AI-first architecture (no UI logic here)
"""

import sys
import os
import asyncio
import psutil
from datetime import datetime

from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# =====================================================
# PATH FIX (Å¼eby widzieÄ‡ core/ml/trading)
# =====================================================
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if BASE_DIR not in sys.path:
    sys.path.append(BASE_DIR)

# =====================================================
# IMPORTY SYSTEMU
# =====================================================
from security.user_manager import UserManager
from trading.wallet import WalletManager
from backend.ai_core import RedlineAICore

# =====================================================
# APP
# =====================================================
app = FastAPI(
    title="REDLINE API",
    version="2.0",
    description="AI Trading & Risk Engine"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =====================================================
# AI CORE (SINGLE INSTANCE)
# =====================================================
ai_core = RedlineAICore(mode="PAPER", timeframe="1h")

# =====================================================
# MODELE
# =====================================================
class LoginRequest(BaseModel):
    username: str
    password: str

# =====================================================
# SYSTEM / HEALTH
# =====================================================
@app.get("/api/status")
def system_status():
    return {
        "status": "ONLINE",
        "engine": "REDLINE_AI_CORE_GEN2",
        "time": datetime.utcnow().isoformat()
    }

# =====================================================
# AUTH
# =====================================================
@app.post("/api/auth/login")
def login(req: LoginRequest):
    role = UserManager.verify_login(req.username, req.password)
    if not role:
        raise HTTPException(status_code=401, detail="Invalid credentials")

    return {
        "user": req.username,
        "role": role,
        "login_time": datetime.utcnow().isoformat()
    }

# =====================================================
# WALLET
# =====================================================
@app.get("/api/wallet")
def wallet():
    return WalletManager.get_wallet_data()

# =====================================================
# AI CORE CONTROL
# =====================================================
@app.get("/api/ai/state")
def ai_state():
    return ai_core.get_state()

@app.post("/api/ai/mode/{mode}")
def set_ai_mode(mode: str):
    try:
        ai_core.set_mode(mode.upper())
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    return ai_core.get_state()

@app.post("/api/ai/run")
def run_ai_once():
    """
    Manual trigger of single AI cycle
    """
    return ai_core.run_once()

@app.post("/api/ai/auto/start")
def start_auto():
    ai_core.start_auto(interval_sec=3600)
    return {
        "status": "AUTO_MODE_STARTED",
        "interval_sec": 3600
    }

@app.post("/api/ai/auto/stop")
def stop_auto():
    ai_core.stop_auto()
    return {
        "status": "AUTO_MODE_STOPPED"
    }

# =====================================================
# HUD â€” REALTIME SYSTEM METRICS
# =====================================================
@app.websocket("/ws/hud")
async def hud_ws(ws: WebSocket):
    await ws.accept()
    try:
        while True:
            wallet = WalletManager.get_wallet_data()

            payload = {
                "time": datetime.now().strftime("%H:%M:%S"),
                "cpu": psutil.cpu_percent(),
                "mem": psutil.virtual_memory().percent,
                "funds": wallet.get("balance", 0.0),
                "ai_mode": ai_core.state["mode"],
                "ai_running": ai_core.state["running"]
            }

            await ws.send_json(payload)
            await asyncio.sleep(1)

    except WebSocketDisconnect:
        pass

==================================================
FILE: core\auto_rotator.py
==================================================
# core/auto_rotator.py
from ml.scanner import MarketScanner
from datetime import datetime

class AutoRotator:
    """
    Manualny moduÅ‚ do jednorazowego uruchomienia skanu rynku.
    (Nie dziaÅ‚a w pÄ™tli - manualny refresh przez UI)
    """

    @staticmethod
    def run_scan(timeframe="1h"):
        print(f"[{datetime.utcnow()}] Starting market scan ({timeframe})...")
        scanner = MarketScanner(timeframe)
        ranked = scanner.scan()
        print(f"Scan completed: {len(ranked)} assets analyzed.")
        return ranked

==================================================
FILE: core\bootstrap.py
==================================================
# core/bootstrap.py
import streamlit as st
import time

def init_session():
    """
    Inicjalizacja globalnego stanu aplikacji.
    Wersja V2: Idempotentna i bezpieczna dla wyÅ›cigu wÄ…tkÃ³w.
    """
    # DomyÅ›lne wartoÅ›ci
    defaults = {
        "sys": {
            "auth": False,
            "role": None,
            "user": None,
            "theme": "MATRIX",
            "logs": [],         # Logi zostajÄ… nawet po wylogowaniu
            "breach": False,    # Flaga wÅ‚amania zostaje
            "bank_link": False,
        },
        "last_active": time.time(),
        "initialized": True
    }

    # Bezpieczna inicjalizacja (tylko brakujÄ…cych kluczy)
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value

def session_watchdog():
    """
    StraÅ¼nik sesji (Watchdog).
    V2: Soft-Reset (zachowuje dowody wÅ‚amania) + Bezpieczny dostÄ™p.
    """
    TIMEOUT_SECONDS = 300  # 5 minut

    # 1. Bezpieczne sprawdzenie inicjalizacji
    if "last_active" not in st.session_state or "sys" not in st.session_state:
        return

    # 2. Bezpieczny pobÃ³r statusu auth (unikamy KeyError)
    is_auth = st.session_state["sys"].get("auth", False)

    if is_auth:
        try:
            # Walidacja typu last_active (ochrona przed prostym spoofingiem typu string)
            last = float(st.session_state["last_active"])
            idle_time = time.time() - last

            if idle_time > TIMEOUT_SECONDS:
                st.warning("SESSION TIMEOUT. SECURE LOCK.")

                # --- SOFT RESET (Forensic preservation) ---
                # Nie robimy clear(), tylko zerujemy dostÄ™p
                st.session_state["sys"]["auth"] = False
                st.session_state["sys"]["user"] = None
                st.session_state["sys"]["role"] = None
                # Logi i flaga 'breach' zostajÄ… w pamiÄ™ci!

                # Wymuszenie przerysowania UI
                st.rerun()
            else:
                # Heartbeat
                st.session_state["last_active"] = time.time()

        except (ValueError, TypeError):
            # JeÅ›li ktoÅ› manipulowaÅ‚ last_active -> natychmiastowy wylot
            st.session_state["sys"]["auth"] = False
            st.rerun()

==================================================
FILE: core\config.py
==================================================
# ================================================================
# REDLINE SYSTEM CONFIGURATION
# ================================================================

# --- SYSTEM DEPENDENCIES (FIX BÅÄ˜DU IMPORTU) ---
REQUIRED_LIBS = [
    "streamlit",
    "pandas",
    "numpy",
    "ccxt",
    "yfinance",
    "ta",
    "textblob",
    "plotly",
    "torch",
    "sklearn"
]

# --- SECURITY ---
SECURITY_SALT = "QUANTUM_ENTROPY_V1"
SECURITY_OVERRIDE_HASH = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" # Empty hash placeholder

# --- UI THEMES ---
# 'p': Primary, 's': Secondary, 't': Text, 'bg': Background, 'err': Error, 'warn': Warning
THEMES = {
    'MATRIX': {
        'p': '#00ff41',    # Matrix Green
        's': '#003b00',    # Dark Green (Secondary)
        't': '#e0e0e0',    # Light Text
        'bg': '#0d0d0d',   # Black Background
        'err': '#ff3b30',  # Red
        'warn': '#ffcc00', # Yellow
        'info': '#00aaff'  # Blue
    },
    'CYBERPUNK': {
        'p': '#ffee00',    # Yellow
        's': '#3d3d00',    # Dark Yellow
        't': '#00f0ff',    # Cyan Text
        'bg': '#0b0b15',   # Deep Blue Bg
        'err': '#ff003c',  # Pink/Red
        'warn': '#ffee00',
        'info': '#00f0ff'
    },
    'CRIMSON': {
        'p': '#ff3b30',    # Red
        's': '#4a0e0b',    # Dark Red
        't': '#ffffff',    # White
        'bg': '#0a0a0a',   # Black
        'err': '#ff0000',
        'warn': '#ff9500',
        'info': '#5ac8fa'
    }
}

==================================================
FILE: core\event_logger.py
==================================================
import os
import json
import uuid
from datetime import datetime as dt

class EventLogger:
    """
    OPS ANALYTICS CORE.
    Append-only, daily-rotated JSONL event logger.
    Supports full trade lifecycle correlation via signal_id / trade_id.
    """

    LOG_DIR = os.path.join("assets", "ops_logs")
    SCHEMA_VERSION = "ops_event_v1"

    # ================================================================
    # INTERNALS
    # ================================================================

    @staticmethod
    def _ensure_dir():
        if not os.path.exists(EventLogger.LOG_DIR):
            os.makedirs(EventLogger.LOG_DIR)

    @staticmethod
    def _generate_signal_id(symbol: str, tf: str) -> str:
        """
        Deterministic + unique-enough signal ID.
        Example: SIG-20260110-BTCUSDT-1H-A1B2
        """
        ts = dt.utcnow().strftime("%Y%m%d%H%M%S")
        rand = uuid.uuid4().hex[:4].upper()
        sym = symbol.replace("/", "")
        return f"SIG-{ts}-{sym}-{tf.upper()}-{rand}"

    @staticmethod
    def _generate_trade_id(symbol: str) -> str:
        """
        Unique trade ID.
        Example: TRD-20260110-BTCUSDT-9F3C
        """
        ts = dt.utcnow().strftime("%Y%m%d%H%M%S")
        rand = uuid.uuid4().hex[:4].upper()
        sym = symbol.replace("/", "")
        return f"TRD-{ts}-{sym}-{rand}"

    @staticmethod
    def _write(event_type: str, payload: dict):
        EventLogger._ensure_dir()

        record = {
            "ts": dt.utcnow().isoformat(),
            "type": event_type,
            "schema": EventLogger.SCHEMA_VERSION,
            "data": payload
        }

        filename = f"{dt.utcnow().strftime('%Y-%m-%d')}.jsonl"
        filepath = os.path.join(EventLogger.LOG_DIR, filename)

        try:
            with open(filepath, "a", encoding="utf-8") as f:
                f.write(json.dumps(record) + "\n")
        except Exception as e:
            print(f"[OPS LOGGER ERROR] {e}")

    # ================================================================
    # PUBLIC API
    # ================================================================

    @staticmethod
    def log_signal(symbol, tf, signal, conf, mqs, htf_trend, ev, reasons=None):
        signal_id = EventLogger._generate_signal_id(symbol, tf)

        EventLogger._write("SIGNAL", {
            "signal_id": signal_id,
            "symbol": symbol,
            "tf": tf,
            "signal": signal,
            "confidence": round(conf, 4),
            "mqs": mqs,
            "htf_trend": htf_trend,
            "ev": round(ev, 4),
            "reasons": reasons or []
        })

        return signal_id  # <-- IMPORTANT: return for chaining

    @staticmethod
    def log_decision(
        symbol,
        signal,
        approved,
        reason,
        size_usd,
        signal_id,
        checks=None,
        reasons=None
    ):
        EventLogger._write("DECISION", {
            "signal_id": signal_id,
            "symbol": symbol,
            "signal": signal,
            "approved": approved,
            "decision_reason": reason,
            "size_usd": round(size_usd, 2),
            "checks": checks or {},
            "reasons": reasons or []
        })

    @staticmethod
    def log_execution(
        symbol,
        side,
        entry_price,
        qty,
        cost,
        order_status,
        signal_id
    ):
        trade_id = EventLogger._generate_trade_id(symbol)

        EventLogger._write("EXECUTION", {
            "trade_id": trade_id,
            "signal_id": signal_id,
            "symbol": symbol,
            "side": side,
            "entry_price": entry_price,
            "qty": qty,
            "cost": round(cost, 2),
            "status": order_status,
            "env": os.getenv("TRADING_MODE", "PAPER")
        })

        return trade_id  # <-- IMPORTANT: return for position tracking

    @staticmethod
    def log_exit(
        symbol,
        entry_price,
        exit_price,
        pnl,
        reason,
        hold_time_min,
        trade_id
    ):
        EventLogger._write("EXIT", {
            "trade_id": trade_id,
            "symbol": symbol,
            "entry_price": entry_price,
            "exit_price": exit_price,
            "pnl": round(pnl, 2),
            "exit_reason": reason,
            "hold_time_min": round(hold_time_min, 1)
        })

==================================================
FILE: core\logger.py
==================================================
# core/logger.py
import streamlit as st
from datetime import datetime

# Dozwolone poziomy logowania (Whitelist)
ALLOWED_LEVELS = ["INFO", "WARN", "ERROR", "SEC", "CRITICAL", "TRADE"]

def log_event(message: str, level: str = "INFO"):
    """
    Centralny logger systemowy V2.
    Zabezpieczony przed RAM Exhaustion i Log Injection.
    """
    if "sys" not in st.session_state:
        return

    # 1. Walidacja Levelu (Anti-Spoofing)
    if level not in ALLOWED_LEVELS:
        level = "UNKNOWN"

    # 2. Sanityzacja i Truncate (Anti-DoS)
    # Usuwamy znaki nowej linii i tniemy do 500 znakÃ³w
    clean_msg = str(message).replace("\n", " ").strip()[:500]

    ts = datetime.now().strftime("%H:%M:%S")
    entry = f"[{ts}] [{level}] {clean_msg}"

    # 3. Bezpieczny zapis
    if "logs" in st.session_state["sys"]:
        st.session_state["sys"]["logs"].insert(0, entry)

        # Hard Limit pamiÄ™ci podrÄ™cznej (ostatnie 200 zdarzeÅ„)
        if len(st.session_state["sys"]["logs"]) > 200:
            st.session_state["sys"]["logs"].pop()

==================================================
FILE: core\orchestrator.py
==================================================
import time
from core.logger import log_event
from ml.scanner import MarketScanner
from trading.decision import DecisionEngine
from trading.execution import ExecutionEngine
from trading.position_manager import PositionManager

class Orchestrator:
    """
    SYSTEM CORE V3 (Ops-Enabled).
    Przekazuje signal_id przez caÅ‚y pipeline.
    """

    def __init__(self, mode="PAPER"):
        self.mode = mode
        self.is_running = False

        self.scanner = MarketScanner(timeframe="1h")
        self.decision_engine = DecisionEngine(mode)
        self.execution_engine = ExecutionEngine(mode)
        self.position_manager = PositionManager(mode)

        log_event(f"ORCHESTRATOR READY [{self.mode}]", "INFO")

    def run_cycle(self):
        if not self.is_running: return

        # 1. RISK CHECK
        self.position_manager.manage_positions()
        is_safe, risk_msg = self.position_manager.check_global_risk()
        if not is_safe:
            log_event(f"LOCKED: {risk_msg}", "ERROR")
            return

        log_event("--- CYCLE START ---", "INFO")

        # 2. SCAN
        opportunities = self.scanner.scan()
        if opportunities.empty: return

        candidates = opportunities.head(3)

        for _, cand in candidates.iterrows():
            # 3. DECISION (Loguje event DECISION)
            approved, reason, size = self.decision_engine.evaluate_entry(cand, risk_status=is_safe)

            if approved:
                log_event(f"GO: {cand['symbol']} (${size})", "succ")

                # 4. EXECUTION (Przekazujemy signal_id, Å¼eby spiÄ…Ä‡ logi)
                sig_id = cand.get('signal_id')
                res = self.execution_engine.execute_order(cand['symbol'], "BUY", size, signal_id=sig_id)

                if res['status'] == 'FILLED':
                    log_event(f"FILLED: {cand['symbol']}", "TRADE")
            else:
                log_event(f"SKIP {cand['symbol']}: {reason}", "WARN")

    def start_loop(self, interval=3600):
        self.is_running = True
        log_event("AUTO-PILOT ON", "succ")
        try:
            while self.is_running:
                self.run_cycle()
                time.sleep(interval)
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        self.is_running = False
        log_event("SYSTEM HALTED", "WARN")

==================================================
FILE: core\security.py
==================================================
import os
import time
import hashlib
import random

class HardwareSecurity:
    """
    CORE SECURITY MODULE.
    Odpowiada za symulacjÄ™ uwierzytelniania sprzÄ™towego (USB Key).
    """

    @staticmethod
    def scan_for_key():
        """
        Skanuje porty (symulacja) w poszukiwaniu klucza dostÄ™pu.
        Naprawia bÅ‚Ä…d: AttributeError: type object 'HardwareSecurity' has no attribute 'scan_for_key'
        Zwraca: (bool success, str drive_path)
        """
        # Symulujemy chwilÄ™ "pracy" dla efektu UI
        time.sleep(0.8)

        # W trybie PAPER/DEV zawsze zwracamy sukces, Å¼ebyÅ› mÃ³gÅ‚ siÄ™ zalogowaÄ‡
        # W wersji LIVE tutaj byÅ‚by kod sprawdzajÄ…cy fizyczne dyski (e.g. win32api.GetLogicalDriveStrings)
        return True, "VIRTUAL_SECURE_DRIVE"

    @staticmethod
    def verify_key_signature(drive_path):
        """
        Symuluje weryfikacjÄ™ kryptograficznÄ… pliku na kluczu.
        """
        time.sleep(0.5)
        # Zawsze True w dev
        return True

    @staticmethod
    def get_hardware_id():
        """Generuje unikalny ID maszyny (fingerprint)"""
        # Symulacja staÅ‚ego ID dla tej sesji
        return hashlib.sha256(b"REDLINE_DEV_MACHINE").hexdigest()[:16].upper()

    @staticmethod
    def generate_2fa_code():
        """Generuje kod 2FA dla sesji"""
        return f"{random.randint(100, 999)}-{random.randint(100, 999)}"

==================================================
FILE: core\__init__.py
==================================================
# core/__init__.py

# FIX: Aktualizacja importÃ³w do wersji Security V2
# Teraz eksportujemy HASH i SALT zamiast jawnego kodu.
from .config import THEMES, SECURITY_OVERRIDE_HASH, SECURITY_SALT, REQUIRED_LIBS
from .logger import log_event
from .bootstrap import init_session, session_watchdog

==================================================
FILE: data\feed.py
==================================================
# data/feed.py - WERSJA PANCERNA

import ccxt
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime

# PrÃ³ba importu wskaÅºnikÃ³w (bezpieczna)
try:
    from data.indicators import TechnicalIndicators
    INDICATORS_AVAILABLE = True
except ImportError:
    print(" ModuÅ‚ indicators niedostÄ™pny lub bÅ‚Ä…d importu ta")
    INDICATORS_AVAILABLE = False

class DataFeed:
    @staticmethod
    def get_market_data(symbol: str, tf: str = "1h", limit: int = 100):
        # 1. Inicjalizacja
        exchange = ccxt.binance({'enableRateLimit': True})
        df = pd.DataFrame()

        try:
            # --- SCENARIUSZ A: KRYPTO (Binance) ---
            if "/" in symbol:
                # PrÃ³ba pobrania Å›wiec (OHLCV)
                try:
                    ohlcv = exchange.fetch_ohlcv(symbol, tf, limit=limit)
                    if ohlcv:
                        df = pd.DataFrame(ohlcv, columns=['time', 'open', 'high', 'low', 'close', 'v'])
                        df['time'] = pd.to_datetime(df['time'], unit='ms')
                except Exception as e:
                    print(f" BÅ‚Ä…d pobierania Å›wiec (OHLCV) dla {symbol}: {e}")

                # RATUNEK: JeÅ›li Å›wiece nie przyszÅ‚y (pusty df), pobieramy chociaÅ¼ AKTUALNÄ„ CENÄ˜
                # To naprawi "NO DATA" w Scannerze i HUDzie
                if df.empty:
                    print(f"ðŸ”„ PrÃ³ba pobrania Tickera (Last Price) dla {symbol}...")
                    ticker = exchange.fetch_ticker(symbol)
                    price = ticker['last']
                    # Tworzymy sztucznÄ… ramkÄ™ danych z jednÄ… liniÄ…, Å¼eby system miaÅ‚ co czytaÄ‡
                    df = pd.DataFrame([{
                        'time': datetime.now(),
                        'open': price, 'high': price, 'low': price, 'close': price, 'v': 0
                    }])

            # --- SCENARIUSZ B: AKCJE (Yahoo) ---
            else:
                df = yf.download(symbol, period="1mo", interval=tf, progress=False).reset_index()
                df.columns = [c.lower() for c in df.columns]
                df.rename(columns={"date": "time", "adj close": "close", "volume": "v"}, inplace=True)

            # --- OBRÃ“BKA DANYCH ---
            if df.empty:
                return pd.DataFrame()

            # Konwersja na liczby
            cols = ['open', 'high', 'low', 'close', 'v']
            for c in cols:
                if c in df.columns:
                    df[c] = pd.to_numeric(df[c], errors='coerce')

            # WskaÅºniki (TA) - Tylko jeÅ›li mamy wystarczajÄ…co duÅ¼o danych
            if INDICATORS_AVAILABLE and len(df) > 14:
                try:
                    df = TechnicalIndicators.add_all(df)
                except Exception:
                    pass # Ignorujemy bÅ‚Ä™dy wskaÅºnikÃ³w, waÅ¼na jest cena

            return df

        except Exception as e:
            print(f" KRYTYCZNY BÅÄ„D FEEDA ({symbol}): {e}")
            return pd.DataFrame()
        finally:
            # Zamykamy poÅ‚Ä…czenie, Å¼eby nie wisiaÅ‚o
            if hasattr(exchange, 'close'):
                # W wersji sync ccxt close nie jest wymagane/awaitowane, ale dla porzÄ…dku
                pass

==================================================
FILE: data\indicators.py
==================================================
# ================================================================
# REDLINE V68 - TECHNICAL INDICATORS MODULE (V4.6-Pro)
# Author: Quant Research Division
# Description:
#   Kompletny zestaw wskaÅºnikÃ³w technicznych uÅ¼ywanych przez
#   moduÅ‚ DeepBrain (AI), MarketRegime oraz DataFeed.
# ================================================================

import pandas as pd
import numpy as np
from ta.momentum import RSIIndicator
from ta.trend import MACD, ADXIndicator, EMAIndicator
from ta.volatility import BollingerBands, AverageTrueRange

class TechnicalIndicators:
    """
    ModuÅ‚ Analityczny V4.6-Pro
    Oblicza zestaw wskaÅºnikÃ³w technicznych wymaganych przez system AI.
    Wymaga kolumn: ['high', 'low', 'close', 'v'] lub ['volume'].
    """

    @staticmethod
    def add_all(df: pd.DataFrame) -> pd.DataFrame:
        """Aplikuje komplet wskaÅºnikÃ³w technicznych (TA)."""
        if df is None or df.empty:
            return df

        try:
            data = df.copy()

            # WybÃ³r kolumny wolumenu
            vol_col = "v" if "v" in data.columns else "volume"

            # ============================================================
            # 1ï¸âƒ£ RSI (Momentum)
            # ============================================================
            rsi = RSIIndicator(close=data["close"], window=14, fillna=True)
            data["rsi"] = rsi.rsi()

            # ============================================================
            # 2ï¸âƒ£ MACD (Trend)
            # ============================================================
            macd = MACD(
                close=data["close"],
                window_slow=26,
                window_fast=12,
                window_sign=9,
                fillna=True
            )
            data["macd"] = macd.macd()
            data["macd_diff"] = macd.macd_diff()
            data["macd_signal"] = macd.macd_signal()

            # ============================================================
            # 3ï¸âƒ£ Bollinger Bands (ZmiennoÅ›Ä‡)
            # ============================================================
            bb = BollingerBands(close=data["close"], window=20, window_dev=2, fillna=True)
            data["bb_high"] = bb.bollinger_hband()
            data["bb_low"] = bb.bollinger_lband()
            data["bb_width"] = bb.bollinger_wband()

            # ============================================================
            # 4ï¸âƒ£ ATR (ZmiennoÅ›Ä‡ absolutna)
            # ============================================================
            atr = AverageTrueRange(
                high=data["high"],
                low=data["low"],
                close=data["close"],
                window=14,
                fillna=True
            )
            data["atr"] = atr.average_true_range()

            # ============================================================
            # 5ï¸âƒ£ ADX (SiÅ‚a trendu)
            # ============================================================
            adx = ADXIndicator(high=data["high"], low=data["low"], close=data["close"], window=14, fillna=True)
            data["adx"] = adx.adx()
            # Dodatkowe skÅ‚adniki DI
            data["di_pos"] = adx.adx_pos()
            data["di_neg"] = adx.adx_neg()

            # ============================================================
            # 6ï¸âƒ£ EMA (Åšrednie kroczÄ…ce)
            # ============================================================
            data["ema_50"] = EMAIndicator(close=data["close"], window=50, fillna=True).ema_indicator()
            data["ema_200"] = EMAIndicator(close=data["close"], window=200, fillna=True).ema_indicator()

            # ============================================================
            # 7ï¸âƒ£ Log Returns (Zwroty logarytmiczne)
            # ============================================================
            data["ret"] = np.log(data["close"] / data["close"].shift(1))

            # ============================================================
            # 8ï¸âƒ£ Sanity Filter / Safety Layer
            # ============================================================
            required_cols = [
                "rsi", "macd", "macd_diff", "macd_signal",
                "bb_high", "bb_low", "bb_width",
                "atr", "adx", "di_pos", "di_neg",
                "ema_50", "ema_200", "ret"
            ]
            for c in required_cols:
                if c not in data.columns:
                    data[c] = 0.0

            # Usuwamy NaN i nieskoÅ„czonoÅ›ci
            data.replace([np.inf, -np.inf], 0, inplace=True)
            data.fillna(0, inplace=True)

            return data

        except Exception as e:
            print(f"[Indicators] Error calculating indicators: {e}")
            return df

==================================================
FILE: data\news.py
==================================================
import random
from textblob import TextBlob

class NewsDesk:
    """ModuÅ‚ Analizy Sentymentu (NLP)"""

    @staticmethod
    def get_sentiment(symbol):
        # Symulowane nagÅ‚Ã³wki (dla celÃ³w demo/testu)
        headlines = [
            f"{symbol} partnership announced with major bank",
            f"Regulatory concerns regarding {symbol} market",
            f"{symbol} breaks all time high resistance level",
            "Global market fear increases due to inflation data",
            f"Analysts predict huge move for {symbol} next week",
            f"{symbol} volume spikes significantly",
            "Bearish divergence spotted on major timeframe"
        ]

        # Losujemy newsa
        news = random.choice(headlines)

        try:
            # Analiza sentymentu (-1.0 do 1.0)
            analysis = TextBlob(news)
            score = analysis.sentiment.polarity
        except:
            score = 0.0

        return score, news

==================================================
FILE: data\__init__.py
==================================================
from .feed import DataFeed
from .news import NewsDesk
from .indicators import TechnicalIndicators

==================================================
FILE: frontend\index.html
==================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>REDLINE v.68</title>
    <style>
  body { margin: 0; background: #f9fafb; color: #111; }
</style>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

==================================================
FILE: frontend\package.json
==================================================
{
  "name": "redline-frontend",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "lucide-react": "^0.300.0",
    "recharts": "^2.10.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.0",
    "vite": "^5.0.0",
    "autoprefixer": "^10.4.16",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.4.0"
  }
}

==================================================
FILE: frontend\vite.config.js
==================================================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    proxy: {
      '/api': 'http://127.0.0.1:8000',
      '/ws': {
        target: 'ws://127.0.0.1:8000',
        ws: true
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})

==================================================
FILE: frontend\src\App.jsx
==================================================
import React, { useState } from 'react';
import { AuthProvider, useAuth } from './auth/AuthContext';
import Login from './views/login';
import Training from './views/training.jsx';

// GÅ‚Ã³wne widoki
import OpsDashboard from './views/OpsDashboard';
import InvestorDashboard from './views/InvestorDashboard';

// Nowe widoki (Capital i Scanner)
import Wallet from './views/wallet';
import Scanner from './views/scanner';

import OpsLayout from './layouts/OpsLayout';

const AppContent = () => {
  const { user } = useAuth();
  const [activeTab, setActiveTab] = useState('dashboard');

  // 1. JeÅ›li brak usera -> Login
  if (!user) {
    return <Login />;
  }

  // 2. Logika wyboru Dashboardu na podstawie roli
  const renderDashboard = () => {
    if (['ROOT', 'ADMIN', 'OPERATOR'].includes(user.role)) {
      return <OpsDashboard />;
    }
    return <InvestorDashboard />;
  };

  return (
    <OpsLayout activeTab={activeTab} setActiveTab={setActiveTab}>

      {/* --- ROUTING ZAKÅADEK --- */}

      {/* 1. Dashboard (Overview) */}
      {activeTab === 'dashboard' && renderDashboard()}

      {/* 2. Capital (Wallet) - Teraz podpiÄ™ty komponent */}
      {activeTab === 'wallet' && <Wallet />}

      {/* 3. Scanner (Trading) - Teraz podpiÄ™ty komponent */}
      {activeTab === 'scanner' && <Scanner />}

      {/* 4. AI Labs (Placeholder) */}
      {activeTab === 'training' && <Training />}
        <div style={{
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: '#999',
          flexDirection: 'column',
          gap: '10px'
        }}>
          <h2 style={{fontWeight: '400'}}>AI Neural Labs</h2>
          <span style={{fontSize: '12px', background: '#eee', padding: '4px 8px', borderRadius: '4px'}}>
            MODULE UNDER CONSTRUCTION
          </span>
        </div>

    </OpsLayout>
  );
};

function App() {
  return (
    <AuthProvider>
      <AppContent />
    </AuthProvider>
  );
}

export default App;

==================================================
FILE: frontend\src\main.jsx
==================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './styles/globals.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

==================================================
FILE: frontend\src\api\auth.js
==================================================

==================================================
FILE: frontend\src\api\client.js
==================================================

==================================================
FILE: frontend\src\api\system.js
==================================================

==================================================
FILE: frontend\src\api\trading.js
==================================================
// frontend/src/api/trading.js
const API_URL = '/api'; // Proxy w vite.config.js przekieruje to na 8000

export const fetchWallet = async () => {
  const res = await fetch(`${API_URL}/wallet`);
  return res.json();
};

export const fetchAssets = async () => {
  const res = await fetch(`${API_URL}/trading/assets`);
  return res.json();
};

export const fetchPositions = async () => {
  const res = await fetch(`${API_URL}/trading/positions`);
  return res.json();
};

export const executeOrder = async (symbol, side, amount) => {
  const res = await fetch(`${API_URL}/trading/order`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ symbol, side, amount, type: 'MARKET' })
  });
  return res.json();
};

==================================================
FILE: frontend\src\auth\AuthContext.jsx
==================================================
import React, { createContext, useState, useContext } from 'react';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(null);
  const [error, setError] = useState(null);

  const login = async (username, password) => {
    try {
      setError(null);
      // StrzaÅ‚ do Twojego FastAPI Backendu
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });

      if (!response.ok) {
        throw new Error('ACCESS DENIED');
      }

      const data = await response.json();

      // Zapisujemy dane uÅ¼ytkownika w stanie aplikacji
      setUser({ username: data.user, role: data.role });
      setToken(data.token);
      return true;

    } catch (err) {
      setError("INVALID CREDENTIALS");
      return false;
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
  };

  return (
    <AuthContext.Provider value={{ user, token, login, logout, error }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);

==================================================
FILE: frontend\src\auth\RequireRole.jsx
==================================================

==================================================
FILE: frontend\src\auth\useAuth.js
==================================================

==================================================
FILE: frontend\src\components\Events\EventCard.jsx
==================================================

==================================================
FILE: frontend\src\components\Events\EventOverlay.jsx
==================================================

==================================================
FILE: frontend\src\components\HUD\HUD.jsx
==================================================

==================================================
FILE: frontend\src\components\HUD\HudItem.jsx
==================================================

==================================================
FILE: frontend\src\components\HUD\HudMinimal.jsx
==================================================

==================================================
FILE: frontend\src\config\endpoints.js
==================================================

==================================================
FILE: frontend\src\config\roles.js
==================================================

==================================================
FILE: frontend\src\config\settings.js
==================================================

==================================================
FILE: frontend\src\layouts\InvestorLayout.jsx
==================================================

==================================================
FILE: frontend\src\layouts\MinimalLayout.jsx
==================================================

==================================================
FILE: frontend\src\layouts\OpsLayout.jsx
==================================================
import React from 'react';
import { useEvents } from '../ws/useEvents';
import { useHud } from '../ws/hud';
import { useAuth } from '../auth/AuthContext';
import { LayoutDashboard, Wallet, ScanLine, Brain, LogOut } from 'lucide-react';

const OpsLayout = ({ children, activeTab, setActiveTab }) => {
  // UÅ¼ywamy hooka useHud wyeksportowanego z pliku hud.js
  const { metrics, connected } = useHud();
  const { logout, user } = useAuth();

  const menuItems = [
    { id: 'dashboard', icon: <LayoutDashboard size={20} />, label: 'Overview' },
    { id: 'wallet', icon: <Wallet size={20} />, label: 'Capital' },
    { id: 'scanner', icon: <ScanLine size={20} />, label: 'Scanner' },
    { id: 'training', icon: <Brain size={20} />, label: 'AI Labs' },
  ];

  // STYLE (Clean Theme)
  const s = {
    layout: { display: 'flex', height: '100vh', background: '#f9fafb', fontFamily: '-apple-system, sans-serif' },
    sidebar: { width: '260px', background: '#fff', borderRight: '1px solid #eaeaea', display: 'flex', flexDirection: 'column', padding: '24px' },
    logo: { fontSize: '20px', fontWeight: '800', letterSpacing: '-0.5px', marginBottom: '40px', display: 'flex', alignItems: 'center', gap: '10px' },
    logoDot: { width: '10px', height: '10px', background: connected ? '#00c853' : '#ff3d00', borderRadius: '50%' },
    menu: { flex: 1, display: 'flex', flexDirection: 'column', gap: '8px' },
    menuItem: (isActive) => ({
      display: 'flex', alignItems: 'center', gap: '12px', padding: '12px 16px', borderRadius: '8px', cursor: 'pointer',
      background: isActive ? '#f4f4f5' : 'transparent', color: isActive ? '#111' : '#666', fontWeight: isActive ? '600' : '500', transition: 'all 0.2s'
    }),
    userSection: { borderTop: '1px solid #eaeaea', paddingTop: '20px', display: 'flex', alignItems: 'center', justifyContent: 'space-between' },
    main: { flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' },
    header: { height: '64px', background: '#fff', borderBottom: '1px solid #eaeaea', display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0 32px' },
    hudItem: { display: 'flex', flexDirection: 'column', alignItems: 'flex-end' },
    hudLabel: { fontSize: '10px', color: '#999', fontWeight: '600', textTransform: 'uppercase' },
    hudValue: { fontSize: '14px', fontWeight: '600', color: '#111', fontFamily: 'monospace' },
    content: { flex: 1, padding: '32px', overflowY: 'auto' }
  };

  return (
    <div style={s.layout}>
      {/* SIDEBAR */}
      <aside style={s.sidebar}>
        <div style={s.logo}>
          <div style={s.logoDot} title={connected ? "System Online" : "Offline"} />
          REDLINE
        </div>

        <nav style={s.menu}>
          {menuItems.map(item => (
            <div
              key={item.id}
              style={s.menuItem(activeTab === item.id)}
              onClick={() => setActiveTab(item.id)}
            >
              {item.icon}
              <span>{item.label}</span>
            </div>
          ))}
        </nav>

        <div style={s.userSection}>
          <div>
            <div style={{fontSize: '13px', fontWeight: '600'}}>{user?.username}</div>
            <div style={{fontSize: '11px', color: '#999'}}>{user?.role}</div>
          </div>
          <button onClick={logout} style={{border:'none', background:'transparent', cursor:'pointer', color:'#666'}}>
            <LogOut size={18} />
          </button>
        </div>
      </aside>

      {/* MAIN CONTENT */}
      <main style={s.main}>
        {/* HUD HEADER */}
        <header style={s.header}>
          <div style={{fontSize: '14px', color: '#666'}}>
            System Time: <span style={{color:'#111', fontWeight:'600'}}>{metrics.time}</span>
          </div>

          <div style={{display:'flex', gap:'32px'}}>
            <div style={s.hudItem}>
              <span style={s.hudLabel}>CPU Load</span>
              <span style={s.hudValue}>{metrics.cpu.toFixed(1)}%</span>
            </div>
            <div style={s.hudItem}>
              <span style={s.hudLabel}>Memory</span>
              <span style={s.hudValue}>{metrics.mem.toFixed(1)}%</span>
            </div>
            <div style={s.hudItem}>
              <span style={s.hudLabel}>Liquid Capital</span>
              <span style={{...s.hudValue, color: '#00c853'}}>${metrics.funds.toLocaleString()}</span>
            </div>
          </div>
        </header>

        {/* PAGE CONTENT */}
        <div style={s.content}>
          {children}
        </div>
      </main>
    </div>
  );
};

export default OpsLayout;

==================================================
FILE: frontend\src\styles\globals.css
==================================================

==================================================
FILE: frontend\src\styles\ops.css
==================================================

==================================================
FILE: frontend\src\styles\theme.js
==================================================

==================================================
FILE: frontend\src\utils\format.js
==================================================

==================================================
FILE: frontend\src\utils\math.js
==================================================

==================================================
FILE: frontend\src\utils\time.js
==================================================

==================================================
FILE: frontend\src\views\InvestorDashboard.jsx
==================================================
import React from 'react';

const WealthCard = ({ label, value }) => (
  <div style={{
    background: '#111', color: '#fff', padding: '32px', borderRadius: '16px',
    boxShadow: '0 10px 30px rgba(0,0,0,0.15)', display:'flex', flexDirection:'column', justifyContent:'center'
  }}>
    <div style={{fontSize: '14px', opacity: 0.7, marginBottom: '8px'}}>{label}</div>
    <div style={{fontSize: '36px', fontWeight: '700', letterSpacing: '-1px'}}>{value}</div>
  </div>
);

const PerfCard = ({ label, value, percent }) => (
  <div style={{
    background: '#fff', padding: '24px', borderRadius: '16px', border: '1px solid #eaeaea'
  }}>
    <div style={{fontSize: '13px', color: '#666', fontWeight: '600'}}>{label}</div>
    <div style={{display:'flex', alignItems:'baseline', gap:'10px', marginTop:'8px'}}>
      <div style={{fontSize: '28px', fontWeight: '700', color: '#111'}}>{value}</div>
      <div style={{fontSize: '14px', color: '#00c853', fontWeight: '600', background:'#e8f5e9', padding:'2px 8px', borderRadius:'12px'}}>
        +{percent}%
      </div>
    </div>
  </div>
);

const InvestorDashboard = () => {
  return (
    <div style={{maxWidth: '1000px', margin: '0 auto'}}>

      {/* WELCOME */}
      <div style={{marginBottom: '40px'}}>
        <h1 style={{fontSize: '28px', fontWeight: '700', margin: 0, color:'#111'}}>Portfolio Overview</h1>
        <p style={{color: '#666', marginTop: '8px', fontSize:'15px'}}>Welcome back. Here is your asset performance.</p>
      </div>

      {/* MAIN ASSETS */}
      <div style={{display: 'grid', gridTemplateColumns: '1.2fr 1fr 1fr', gap: '24px', marginBottom: '40px'}}>
        <WealthCard label="Total Equity (NAV)" value="$12,450.00" />
        <PerfCard label="Monthly Return" value="+$840.50" percent="7.2" />
        <PerfCard label="All-Time Profit" value="+$2,450.00" percent="24.5" />
      </div>

      {/* CHART SECTION */}
      <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '32px', height: '350px'}}>
        <div style={{display:'flex', justifyContent:'space-between'}}>
          <h3 style={{margin: 0, fontSize: '18px', fontWeight: '600'}}>Capital Growth</h3>
          <select style={{border:'1px solid #ddd', borderRadius:'6px', padding:'4px 8px', fontSize:'13px'}}>
            <option>Last 30 Days</option>
            <option>YTD</option>
          </select>
        </div>

        {/* Placeholder na wykres */}
        <div style={{height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: '#ccc', fontSize: '14px'}}>
          [Interactive Performance Chart Area]
        </div>
      </div>

    </div>
  );
};

export default InvestorDashboard;

==================================================
FILE: frontend\src\views\login.jsx
==================================================
import React, { useState } from 'react';
import { useAuth } from '../auth/AuthContext';

const Login = () => {
  const { login, error } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    await login(username, password);
    setLoading(false);
  };

  // STYLE OBJECTS (CSS-in-JS dla prostoty)
  const styles = {
    container: {
      height: '100vh',
      width: '100vw',
      background: '#f9fafb', // Bardzo jasny szary (Premium feel)
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    },
    card: {
      width: '100%',
      maxWidth: '400px',
      background: '#ffffff',
      borderRadius: '16px', // ZaokrÄ…glone rogi
      padding: '48px',
      boxShadow: '0 4px 20px rgba(0, 0, 0, 0.05)', // Delikatny cieÅ„
      border: '1px solid #eaeaea',
    },
    header: {
      textAlign: 'center',
      marginBottom: '32px',
    },
    title: {
      fontSize: '24px',
      fontWeight: '700',
      color: '#111',
      marginBottom: '8px',
      letterSpacing: '-0.5px',
    },
    subtitle: {
      fontSize: '14px',
      color: '#666',
    },
    formGroup: {
      marginBottom: '20px',
    },
    label: {
      display: 'block',
      fontSize: '13px',
      fontWeight: '600',
      color: '#333',
      marginBottom: '8px',
    },
    input: {
      width: '100%',
      padding: '12px 16px',
      borderRadius: '8px',
      border: '1px solid #e0e0e0',
      fontSize: '15px',
      outline: 'none',
      transition: 'all 0.2s',
      color: '#333',
      boxSizing: 'border-box', // WaÅ¼ne Å¼eby padding nie rozwalaÅ‚ szerokoÅ›ci
    },
    button: {
      width: '100%',
      padding: '14px',
      background: '#111', // CzerÅ„ absolutna
      color: '#fff',
      border: 'none',
      borderRadius: '8px',
      fontSize: '14px',
      fontWeight: '600',
      cursor: 'pointer',
      marginTop: '10px',
      transition: 'opacity 0.2s',
    },
    error: {
      background: '#fff2f2',
      color: '#d32f2f',
      padding: '10px',
      borderRadius: '6px',
      fontSize: '13px',
      textAlign: 'center',
      marginBottom: '20px',
    }
  };

  return (
    <div style={styles.container}>
      <div style={styles.card}>

        {/* HEADER */}
        <div style={styles.header}>
          <h1 style={styles.title}>Redline</h1>
          <p style={styles.subtitle}>Sign in to access your terminal</p>
        </div>

        {/* ERROR MESSAGE */}
        {error && <div style={styles.error}>{error}</div>}

        {/* FORM */}
        <form onSubmit={handleSubmit}>
          <div style={styles.formGroup}>
            <label style={styles.label}>Identity</label>
            <input
              type="text"
              placeholder="Enter your username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              style={styles.input}
              onFocus={(e) => e.target.style.borderColor = '#111'}
              onBlur={(e) => e.target.style.borderColor = '#e0e0e0'}
            />
          </div>

          <div style={styles.formGroup}>
            <label style={styles.label}>Access Token</label>
            <input
              type="password"
              placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              style={styles.input}
              onFocus={(e) => e.target.style.borderColor = '#111'}
              onBlur={(e) => e.target.style.borderColor = '#e0e0e0'}
            />
          </div>

          <button
            type="submit"
            disabled={loading}
            style={{...styles.button, opacity: loading ? 0.7 : 1}}
          >
            {loading ? "Verifying..." : "Sign In"}
          </button>
        </form>
      </div>
    </div>
  );
};

export default Login;

==================================================
FILE: frontend\src\views\OpsDashboard.jsx
==================================================
import React from 'react';

const StatCard = ({ label, value, sub, status }) => (
  <div style={{
    background: '#fff', padding: '24px', borderRadius: '12px', border: '1px solid #eaeaea',
    boxShadow: '0 2px 5px rgba(0,0,0,0.02)', display: 'flex', flexDirection: 'column', justifyContent: 'space-between'
  }}>
    <div>
      <div style={{fontSize: '11px', color: '#888', fontWeight: '700', textTransform: 'uppercase', letterSpacing: '0.5px'}}>{label}</div>
      <div style={{fontSize: '24px', fontWeight: '700', marginTop: '8px', color: '#111', fontFamily: 'monospace'}}>{value}</div>
    </div>
    {sub && (
      <div style={{fontSize: '12px', marginTop: '12px', color: status === 'good' ? '#00c853' : status === 'bad' ? '#ff3d00' : '#666', fontWeight: '600'}}>
        {sub}
      </div>
    )}
  </div>
);

const SystemStatus = ({ name, status }) => (
  <div style={{display:'flex', justifyContent:'space-between', padding:'12px 0', borderBottom:'1px solid #f4f4f5'}}>
    <span style={{fontSize:'13px', color:'#444'}}>{name}</span>
    <span style={{fontSize:'12px', fontWeight:'600', color: status === 'OK' ? '#00c853' : '#ff3d00'}}>
      {status === 'OK' ? 'â— ONLINE' : 'â— ERROR'}
    </span>
  </div>
);

const OpsDashboard = () => {
  return (
    <div>
      {/* HEADER */}
      <div style={{marginBottom: '32px', display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <div>
          <h1 style={{fontSize: '24px', fontWeight: '700', margin: 0, color:'#111'}}>System Operations</h1>
          <p style={{color: '#666', marginTop: '4px', fontSize:'14px'}}>Live monitoring & risk assessment</p>
        </div>
        <div style={{background:'#e3f2fd', color:'#1565c0', padding:'6px 12px', borderRadius:'6px', fontSize:'12px', fontWeight:'600'}}>
          MODE: PAPER TRADING
        </div>
      </div>

      {/* KPI GRID */}
      <div style={{display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '20px', marginBottom: '32px'}}>
        <StatCard label="Daily PnL" value="+$324.50" sub="â–² 2.4% vs Avg" status="good" />
        <StatCard label="Risk Exposure" value="12.5%" sub="Limit: 20%" status="good" />
        <StatCard label="Win Rate (24h)" value="72%" sub="18 Trades" status="good" />
        <StatCard label="Sharpe Ratio" value="1.84" sub="Risk Adjusted" status="neutral" />
      </div>

      <div style={{display: 'grid', gridTemplateColumns: '2fr 1fr', gap: '24px'}}>

        {/* ACTIVE TRADES TABLE */}
        <div style={{background: '#fff', borderRadius: '12px', border: '1px solid #eaeaea', padding: '24px'}}>
          <h3 style={{margin: '0 0 20px 0', fontSize: '16px', fontWeight: '600'}}>Active Positions</h3>
          <table style={{width:'100%', borderCollapse:'collapse', fontSize:'13px'}}>
            <thead>
              <tr style={{textAlign:'left', color:'#888', borderBottom:'1px solid #eee'}}>
                <th style={{paddingBottom:'10px'}}>Symbol</th>
                <th style={{paddingBottom:'10px'}}>Side</th>
                <th style={{paddingBottom:'10px'}}>Entry</th>
                <th style={{paddingBottom:'10px'}}>PnL</th>
              </tr>
            </thead>
            <tbody>
              {/* MOCK DATA */}
              <tr><td style={{padding:'12px 0'}}>BTC/USDT</td><td style={{color:'#00c853'}}>LONG</td><td>$43,250</td><td style={{color:'#00c853'}}>+$120.00</td></tr>
              <tr><td style={{padding:'12px 0'}}>ETH/USDT</td><td style={{color:'#00c853'}}>LONG</td><td>$2,250</td><td style={{color:'#ff3d00'}}>-$-15.50</td></tr>
            </tbody>
          </table>
        </div>

        {/* SYSTEM HEALTH */}
        <div style={{background: '#fff', borderRadius: '12px', border: '1px solid #eaeaea', padding: '24px'}}>
          <h3 style={{margin: '0 0 10px 0', fontSize: '16px', fontWeight: '600'}}>Node Health</h3>
          <SystemStatus name="Execution Engine" status="OK" />
          <SystemStatus name="Data Feeds (CCXT)" status="OK" />
          <SystemStatus name="Neural Brain" status="OK" />
          <SystemStatus name="Risk Guardian" status="OK" />
        </div>
      </div>
    </div>
  );
};

export default OpsDashboard;

==================================================
FILE: frontend\src\views\scanner.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { fetchPositions, executeOrder } from '../api/trading';
import { ArrowUpRight, ArrowDownRight, Radar, Zap } from 'lucide-react';

const Scanner = () => {
  const [positions, setPositions] = useState([]);
  const [signals, setSignals] = useState([]); // Nowy stan dla sygnaÅ‚Ã³w AI
  const [scanning, setScanning] = useState(false);

  // Stan formularza manualnego
  const [symbol, setSymbol] = useState('BTC/USDT');

  // 1. Pobieranie pozycji na start
  const loadData = () => {
    fetchPositions().then(setPositions);
  };

  useEffect(() => {
    loadData();
    // OdÅ›wieÅ¼anie pozycji co 5 sekund
    const interval = setInterval(loadData, 5000);
    return () => clearInterval(interval);
  }, []);

  // 2. ObsÅ‚uga Manualnego Trade'u
  const handleTrade = async (side, targetSymbol = null) => {
    const sym = targetSymbol || symbol;
    try {
      // UÅ¼ywamy executeOrder z api/trading.js
      const res = await executeOrder(sym, side, 100);
      if (res.status === 'FILLED') {
        alert(` SUCCESS!\nOrder ID: ${res.order_id}\nPrice: $${res.price}`);
        loadData(); // OdÅ›wieÅ¼ tabelÄ™
      } else {
        alert(`ERROR: ${res.reason}`);
      }
    } catch (e) {
      alert(` NETWORK ERROR: ${e.message}`);
    }
  };

  // 3. ObsÅ‚uga Skanera AI
  const runAiScan = async () => {
    setScanning(true);
    try {
      const res = await fetch('http://localhost:8000/api/scanner/run');
      const data = await res.json();
      setSignals(data);
    } catch (e) {
      console.error(e);
      alert("Scan Failed. Check Backend Console.");
    }
    setScanning(false);
  };

  return (
    <div>
      {/* HEADER */}
      <div style={{marginBottom: '32px', display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <div>
            <h1 style={{fontSize: '24px', fontWeight: '700', margin: 0, color:'#111'}}>Market Scanner</h1>
            <p style={{color: '#666', marginTop: '4px'}}>AI Opportunity Detection & Execution</p>
        </div>
        <button
            onClick={runAiScan}
            disabled={scanning}
            style={{
                padding:'12px 24px',
                background: scanning ? '#ccc' : '#2962ff',
                color:'#fff', border:'none', borderRadius:'8px', cursor: scanning ? 'wait' : 'pointer',
                fontWeight:'600', display:'flex', alignItems:'center', gap:'10px'
            }}>
            {scanning ? <Radar className="animate-spin" size={20}/> : <Radar size={20}/>}
            {scanning ? 'SCANNING...' : 'RUN AI SCAN'}
        </button>
      </div>

      <div style={{display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '24px'}}>

        {/* LEWA: MANUAL + SIGNALS */}
        <div style={{display:'flex', flexDirection:'column', gap:'24px'}}>

            {/* MANUAL ENTRY CARD */}
            <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px'}}>
            <h3 style={{margin: '0 0 20px 0', fontSize: '16px', fontWeight: '600'}}>Manual Entry</h3>
            <div style={{marginBottom:'15px'}}>
                <label style={{display:'block', fontSize:'12px', fontWeight:'600', marginBottom:'8px'}}>Symbol</label>
                <input
                value={symbol} onChange={e => setSymbol(e.target.value)}
                style={{width:'100%', padding:'12px', border:'1px solid #eee', borderRadius:'8px', fontSize:'14px', boxSizing:'border-box'}}
                />
            </div>
            <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'12px'}}>
                <button onClick={() => handleTrade('BUY')} style={{padding:'14px', background:'#00c853', color:'#fff', border:'none', borderRadius:'8px', cursor:'pointer', fontWeight:'700'}}>LONG</button>
                <button onClick={() => handleTrade('SELL')} style={{padding:'14px', background:'#ff3d00', color:'#fff', border:'none', borderRadius:'8px', cursor:'pointer', fontWeight:'700'}}>SHORT</button>
            </div>
            </div>

            {/* AI SIGNALS LIST */}
            {signals.length > 0 && (
                <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '0', overflow:'hidden'}}>
                    <div style={{padding:'20px', borderBottom:'1px solid #eee', background:'#f8f9fa'}}>
                        <h3 style={{margin:0, fontSize:'14px', fontWeight:'700', display:'flex', alignItems:'center', gap:'8px'}}>
                            <Zap size={16} fill="#ffeb3b" color="#fbc02d"/> DETECTED OPPORTUNITIES
                        </h3>
                    </div>
                    <div>
                        {signals.map((sig, i) => (
                            <div key={i} style={{padding:'16px 20px', borderBottom:'1px solid #eee', display:'flex', justifyContent:'space-between', alignItems:'center'}}>
                                <div>
                                    <div style={{fontWeight:'700', fontSize:'14px'}}>{sig.symbol}</div>
                                    <div style={{fontSize:'11px', color:'#666'}}>Conf: {(sig.conf*100).toFixed(0)}% | EV: {sig.ev?.toFixed(2)}</div>
                                </div>
                                <div style={{textAlign:'right'}}>
                                    <div style={{fontSize:'12px', fontWeight:'700', color: sig.signal === 'BUY' ? '#00c853' : '#ff3d00'}}>{sig.signal}</div>
                                    <button
                                        onClick={() => handleTrade(sig.signal, sig.symbol)}
                                        style={{marginTop:'6px', padding:'4px 12px', fontSize:'11px', background:'#111', color:'#fff', border:'none', borderRadius:'4px', cursor:'pointer'}}>
                                        EXECUTE
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            )}
        </div>

        {/* PRAWA: OPEN POSITIONS */}
        <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px', height:'fit-content'}}>
          <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:'20px'}}>
            <h3 style={{margin: 0, fontSize: '16px', fontWeight: '600'}}>Portfolio Positions</h3>
            <div style={{background:'#e8f5e9', color:'#00c853', padding:'4px 8px', borderRadius:'6px', fontSize:'11px', fontWeight:'700'}}>LIVE</div>
          </div>

          <table style={{width:'100%', borderCollapse:'collapse', fontSize:'13px'}}>
            <thead>
              <tr style={{textAlign:'left', color:'#888', borderBottom:'1px solid #eee'}}>
                <th style={{padding:'10px 0'}}>Asset</th>
                <th style={{padding:'10px 0'}}>Side</th>
                <th style={{padding:'10px 0'}}>Size</th>
                <th style={{padding:'10px 0'}}>Entry</th>
                <th style={{padding:'10px 0'}}>Live Price</th>
                <th style={{padding:'10px 0'}}>PnL</th>
              </tr>
            </thead>
            <tbody>
              {positions.map((p, i) => (
                <tr key={i} style={{borderBottom: '1px solid #f9f9f9'}}>
                  <td style={{padding:'14px 0', fontWeight:'600'}}>{p.symbol}</td>
                  <td style={{padding:'14px 0', color: p.side === 'LONG' ? '#00c853' : '#ff3d00', fontWeight:'700'}}>{p.side}</td>
                  <td style={{padding:'14px 0'}}>{p.size}</td>
                  <td style={{padding:'14px 0'}}>${p.entry_price.toLocaleString()}</td>
                  <td style={{padding:'14px 0', fontFamily:'monospace'}}>${p.current_price?.toLocaleString()}</td>
                  <td style={{padding:'14px 0', fontWeight:'600', color: p.pnl > 0 ? '#00c853' : '#ff3d00'}}>
                    {p.pnl > 0 ? '+' : ''}{p.pnl.toFixed(2)}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>

          {positions.length === 0 && (
            <div style={{padding:'40px', textAlign:'center', color:'#999', fontSize:'13px'}}>
              No active positions. Run Scanner to find setups.
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default Scanner;

==================================================
FILE: frontend\src\views\system.jsx
==================================================

==================================================
FILE: frontend\src\views\training.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { Brain, Play, Square, Activity, Save } from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

const Training = () => {
  const [status, setStatus] = useState(null);
  const [chartData, setChartData] = useState([]);
  const [isTraining, setIsTraining] = useState(false);

  // Pobieramy dane z API
  useEffect(() => {
    // 1. Status modelu
    fetch('/api/ml/status').then(res => res.json()).then(setStatus);
    // 2. Dane do wykresu
    fetch('/api/ml/chart').then(res => res.json()).then(setChartData);
  }, []);

  const toggleTraining = () => {
    setIsTraining(!isTraining);
    // Tu wysyÅ‚alibyÅ›my POST /api/ml/train
  };

  if (!status) return <div style={{padding:'40px'}}>Loading Neural Core...</div>;

  return (
    <div>
      {/* HEADER */}
      <div style={{marginBottom: '32px', display:'flex', justifyContent:'space-between', alignItems:'center'}}>
        <div>
          <h1 style={{fontSize: '24px', fontWeight: '700', margin: 0, color:'#111'}}>Neural Labs</h1>
          <p style={{color: '#666', marginTop: '4px'}}>Model training & hyperparameter tuning</p>
        </div>
        <div style={{display:'flex', gap:'10px'}}>
            <span style={{padding:'8px 16px', background:'#f4f4f5', borderRadius:'8px', fontSize:'13px', fontWeight:'600', color:'#555'}}>
                v.{status.model_version}
            </span>
            <button style={{display:'flex', gap:'8px', alignItems:'center', padding:'8px 16px', background:'#111', color:'#fff', border:'none', borderRadius:'8px', cursor:'pointer', fontSize:'13px'}}>
                <Save size={16} /> Save Model
            </button>
        </div>
      </div>

      <div style={{display: 'grid', gridTemplateColumns: '2fr 1fr', gap: '24px'}}>

        {/* LEWA KOLUMNA: WYKRES */}
        <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px', height: '400px', display:'flex', flexDirection:'column'}}>
            <div style={{marginBottom:'20px', display:'flex', justifyContent:'space-between'}}>
                <h3 style={{margin:0, fontSize:'16px', fontWeight:'600'}}>Loss Function (Learning Curve)</h3>
                <div style={{display:'flex', gap:'15px', fontSize:'12px'}}>
                    <span style={{color:'#8884d8'}}>â— Loss</span>
                    <span style={{color:'#82ca9d'}}>â— Accuracy</span>
                </div>
            </div>

            <div style={{flex:1}}>
                <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={chartData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#eee" />
                        <XAxis dataKey="epoch" stroke="#999" fontSize={12} />
                        <YAxis stroke="#999" fontSize={12} />
                        <Tooltip contentStyle={{background:'#fff', borderRadius:'8px', border:'1px solid #eee'}} />
                        <Line type="monotone" dataKey="loss" stroke="#8884d8" strokeWidth={2} dot={false} />
                        <Line type="monotone" dataKey="accuracy" stroke="#82ca9d" strokeWidth={2} dot={false} />
                    </LineChart>
                </ResponsiveContainer>
            </div>
        </div>

        {/* PRAWA KOLUMNA: PANEL STEROWANIA */}
        <div style={{display:'flex', flexDirection:'column', gap:'20px'}}>

            {/* STATUS CARD */}
            <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px'}}>
                <div style={{fontSize:'12px', textTransform:'uppercase', color:'#888', fontWeight:'700', marginBottom:'10px'}}>Current Status</div>
                <div style={{display:'flex', alignItems:'center', gap:'10px', marginBottom:'20px'}}>
                    <div style={{width:'12px', height:'12px', borderRadius:'50%', background: isTraining ? '#2962ff' : '#ddd'}} className={isTraining ? 'animate-pulse' : ''}></div>
                    <span style={{fontSize:'18px', fontWeight:'700', color: isTraining ? '#2962ff' : '#111'}}>
                        {isTraining ? 'TRAINING IN PROGRESS...' : 'MODEL IDLE'}
                    </span>
                </div>

                <div style={{marginBottom:'15px'}}>
                    <div style={{display:'flex', justifyContent:'space-between', fontSize:'13px', marginBottom:'5px'}}>
                        <span>Epoch Progress</span>
                        <span>{status.current_epoch} / {status.total_epochs}</span>
                    </div>
                    <div style={{width:'100%', height:'6px', background:'#f4f4f5', borderRadius:'3px', overflow:'hidden'}}>
                        <div style={{width: `${(status.current_epoch / status.total_epochs) * 100}%`, height:'100%', background:'#111'}}></div>
                    </div>
                </div>

                <div style={{display:'grid', gridTemplateColumns:'1fr 1fr', gap:'10px', marginTop:'20px', paddingTop:'20px', borderTop:'1px solid #f4f4f5'}}>
                    <div>
                        <div style={{fontSize:'11px', color:'#999'}}>ACCURACY</div>
                        <div style={{fontSize:'20px', fontWeight:'700'}}>{(status.accuracy * 100).toFixed(1)}%</div>
                    </div>
                    <div>
                        <div style={{fontSize:'11px', color:'#999'}}>LOSS</div>
                        <div style={{fontSize:'20px', fontWeight:'700'}}>{status.loss}</div>
                    </div>
                </div>
            </div>

            {/* ACTIONS */}
            <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px'}}>
                <h3 style={{margin:'0 0 15px 0', fontSize:'15px', fontWeight:'600'}}>Controls</h3>
                <button
                    onClick={toggleTraining}
                    style={{
                        width:'100%', padding:'14px', borderRadius:'8px', border:'none', cursor:'pointer',
                        background: isTraining ? '#ff3d00' : '#00c853',
                        color:'#fff', fontWeight:'600', display:'flex', justifyContent:'center', alignItems:'center', gap:'10px'
                    }}>
                    {isTraining ? <Square size={18} fill="currentColor" /> : <Play size={18} fill="currentColor" />}
                    {isTraining ? 'STOP TRAINING' : 'START TRAINING'}
                </button>
            </div>

        </div>
      </div>
    </div>
  );
};

export default Training;

==================================================
FILE: frontend\src\views\wallet.jsx
==================================================
import React, { useEffect, useState } from 'react';
import { fetchAssets } from '../api/trading';
import { Wallet as WalletIcon } from 'lucide-react';

const Wallet = () => {
  const [assets, setAssets] = useState([]);

  useEffect(() => {
    fetchAssets().then(data => {
      setAssets(data);
    });
  }, []);

  return (
    <div>
      <div style={{marginBottom: '32px'}}>
        <h1 style={{fontSize: '24px', fontWeight: '700', margin: 0, color:'#111'}}>Capital Allocation</h1>
        <p style={{color: '#666', marginTop: '4px'}}>Asset distribution & reserves</p>
      </div>

      <div style={{display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '24px'}}>

        {/* LEFT: SUMMARY CARD */}
        <div style={{background: '#111', color: '#fff', padding: '32px', borderRadius: '16px', display:'flex', flexDirection:'column', justifyContent:'space-between'}}>
          <div>
            <div style={{display:'flex', alignItems:'center', gap:'10px', opacity:0.8, marginBottom:'10px'}}>
              <WalletIcon size={20} />
              <span style={{fontSize:'14px'}}>Liquid Funds</span>
            </div>
            <div style={{fontSize: '36px', fontWeight: '700'}}>${assets.length > 0 ? assets[0].balance.toLocaleString() : '---'}</div>
          </div>
          <div style={{fontSize:'13px', opacity:0.6}}>USDT Dominance: 75%</div>
        </div>

        {/* RIGHT: ASSETS TABLE */}
        <div style={{background: '#fff', borderRadius: '16px', border: '1px solid #eaeaea', padding: '24px'}}>
          <h3 style={{margin: '0 0 20px 0', fontSize: '16px', fontWeight: '600'}}>Holdings</h3>
          <table style={{width:'100%', borderCollapse:'collapse', fontSize:'14px'}}>
            <thead>
              <tr style={{textAlign:'left', color:'#888', borderBottom:'1px solid #eee'}}>
                <th style={{padding:'10px 0'}}>Asset</th>
                <th style={{padding:'10px 0'}}>Balance</th>
                <th style={{padding:'10px 0'}}>Allocation</th>
                <th style={{padding:'10px 0', textAlign:'right'}}>Action</th>
              </tr>
            </thead>
            <tbody>
              {assets.map((a, i) => (
                <tr key={i} style={{borderBottom: i !== assets.length-1 ? '1px solid #f9f9f9' : 'none'}}>
                  <td style={{padding:'16px 0', fontWeight:'600'}}>{a.asset}</td>
                  <td style={{padding:'16px 0'}}>{a.balance.toLocaleString()}</td>
                  <td style={{padding:'16px 0'}}>
                    <div style={{display:'flex', alignItems:'center', gap:'8px'}}>
                      <div style={{width:'60px', height:'6px', background:'#eee', borderRadius:'3px', overflow:'hidden'}}>
                        <div style={{width: `${a.allocation}%`, height:'100%', background:'#111'}}></div>
                      </div>
                      <span style={{fontSize:'12px', color:'#666'}}>{a.allocation}%</span>
                    </div>
                  </td>
                  <td style={{textAlign:'right'}}>
                    <button style={{padding:'6px 12px', border:'1px solid #eee', background:'transparent', borderRadius:'6px', cursor:'pointer', fontSize:'12px'}}>
                      View
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default Wallet;

==================================================
FILE: frontend\src\ws\hud.js
==================================================
import { useState, useEffect, useRef } from 'react';

export const useHud = () => {
  const [metrics, setMetrics] = useState({
    cpu: 0,
    mem: 0,
    funds: 0,
    time: '--:--:--'
  });
  const [connected, setConnected] = useState(false);
  const ws = useRef(null);

  useEffect(() => {
    const connect = () => {
      // ÅÄ…czymy siÄ™ z Twoim Backendem (przez Proxy z vite.config.js)
      ws.current = new WebSocket('ws://localhost:3000/ws/hud');

      ws.current.onopen = () => {
        setConnected(true);
        console.log('[WS] HUD Connected');
      };

      ws.current.onmessage = (event) => {
        const data = JSON.parse(event.data);
        setMetrics(data);
      };

      ws.current.onclose = () => {
        setConnected(false);
        // PrÃ³ba ponownego poÅ‚Ä…czenia po 3 sekundach
        setTimeout(connect, 3000);
      };
    };

    connect();

    return () => {
      if (ws.current) ws.current.close();
    };
  }, []);

  return { metrics, connected };
};

==================================================
FILE: frontend\src\ws\reconnect.js
==================================================

==================================================
FILE: frontend\src\ws\useEvents.js
==================================================
import { useEffect, useRef } from 'react';

export const useEvents = (scope = "OPS") => {
  const ws = useRef(null);

  useEffect(() => {
    // ÅÄ…czymy siÄ™ z tym samym portem co Backend (przez proxy Vite)
    // UWAGA: Proxy przekieruje /ws na port 8000
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.host; // zazwyczaj localhost:3000

    const connect = () => {
      ws.current = new WebSocket(`${protocol}//${host}/ws/events?scope=${scope}`);

      ws.current.onopen = () => {
        console.log(`[WS] Events Connected (${scope})`);
      };

      ws.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);

          // Ignorujemy Heartbeat w konsoli, Å¼eby nie Å›mieciÄ‡
          if (data.type !== 'HEARTBEAT') {
            // Tutaj w przyszÅ‚oÅ›ci wepniemy system "Toasts" (dymki powiadomieÅ„)
            console.log("ðŸ”” EVENT:", data);

            // Prosty alert browsera dla testu (tylko dla waÅ¼nych bÅ‚Ä™dÃ³w)
            if (data.level === 'error') {
               alert(`SYSTEM ALERT: ${data.message}`);
            }
          }
        } catch (e) {
          console.error("Event Parse Error", e);
        }
      };

      ws.current.onclose = () => {
        console.log('[WS] Events Disconnected. Reconnecting...');
        setTimeout(connect, 5000);
      };
    };

    connect();

    return () => {
      if (ws.current) ws.current.close();
    };
  }, [scope]);
};

==================================================
FILE: ml\brain.py
==================================================
import os
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from datetime import datetime
from torch.utils.data import Dataset, DataLoader
from sklearn.preprocessing import StandardScaler
from ta.volatility import AverageTrueRange
from ta.momentum import RSIIndicator
from ta.trend import MACD

# Integracja systemowa
from .regime import MarketRegime
from .knowledge import KnowledgeBase

# ================================================================
# ARCHITECTURE (Monte Carlo Dropout Enabled)
# ================================================================

class TimeSeriesDataset(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

class NeuralNet(nn.Module):
    """
    DeepBrain V6 Core.
    Wymuszone Dropout layers dla oceny epistemicznej niepewnoÅ›ci (MC Dropout).
    """
    def __init__(self, input_dim, hidden_dim=64, num_layers=2, dropout=0.2, arch_type='LSTM'):
        super(NeuralNet, self).__init__()
        self.arch_type = arch_type

        if arch_type == 'GRU':
            self.rnn = nn.GRU(input_dim, hidden_dim, num_layers, batch_first=True, dropout=dropout)
        else:
            self.rnn = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True, dropout=dropout)

        self.fc = nn.Sequential(
            nn.Linear(hidden_dim, 32),
            nn.ReLU(),
            nn.Dropout(dropout), # Critical for Uncertainty Estimation
            nn.Linear(32, 1)
        )

    def forward(self, x):
        out, _ = self.rnn(x)
        out = out[:, -1, :] # Last Step Context
        prediction = self.fc(out)
        return prediction

# ================================================================
# DEEP BRAIN ENGINE V6 (Institutional Grade)
# ================================================================

class DeepBrain:
    def __init__(self, lookback=60):
        self.lookback = lookback
        self.model_path = os.path.join("assets", "redline_brain_v6.pt")
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        # Local Context Scaler (Anti-Leakage)
        self.scaler = StandardScaler()
        self.model = None
        self.current_arch = "LSTM"
        self.is_trained = False
        self.last_train_loss = 0.0

    # ------------------------------------------------------------
    # Feature Engineering (Log Returns Target)
    # ------------------------------------------------------------
    def _prepare_data(self, df, is_inference=False):
        if df.empty or len(df) < self.lookback + 5:
            return None, None

        data = df.copy()

        # 1. Target: Log Returns (Dynamika, nie cena)
        data['log_ret'] = np.log(data['close'] / data['close'].shift(1))

        # 2. Features (Robust check)
        if 'atr' not in data:
            data['atr'] = AverageTrueRange(data['high'], data['low'], data['close'], window=14).average_true_range()
        if 'rsi' not in data:
            data['rsi'] = RSIIndicator(data['close'], 14).rsi()
        if 'macd' not in data:
            macd = MACD(data['close'])
            data['macd'] = macd.macd()
            data['macd_diff'] = macd.macd_diff()

        data.dropna(inplace=True)
        feature_cols = ['log_ret', 'atr', 'rsi', 'macd', 'macd_diff']

        # 3. Scaling (Local Context Protection)
        try:
            # Zawsze fitujemy lokalnie, aby uniknÄ…Ä‡ cross-asset leakage w Skanerze
            scaled_data = self.scaler.fit_transform(data[feature_cols])
        except ValueError:
            return None, None

        X, y = [], []
        target_col_idx = 0

        for i in range(self.lookback, len(scaled_data)):
            X.append(scaled_data[i-self.lookback:i])
            y.append(scaled_data[i, target_col_idx])

        return np.array(X), np.array(y)

    # ------------------------------------------------------------
    # Training Loop (Online Adaptation)
    # ------------------------------------------------------------
    def train_on_fly(self, df, epochs=15):
        X, y = self._prepare_data(df, is_inference=False)
        if X is None: return False

        dataset = TimeSeriesDataset(X, y)
        loader = DataLoader(dataset, batch_size=32, shuffle=True)

        # Auto-Switch Architecture based on Volatility Regime
        atr_val = df['atr'].iloc[-1] if 'atr' in df else 0
        self.current_arch = 'GRU' if atr_val > df['close'].iloc[-1] * 0.02 else 'LSTM'

        if self.model is None:
            input_dim = X.shape[2]
            self.model = NeuralNet(input_dim, arch_type=self.current_arch).to(self.device)

        optimizer = torch.optim.Adam(self.model.parameters(), lr=0.001, weight_decay=1e-5)
        criterion = nn.MSELoss()

        self.model.train()
        losses = []
        for _ in range(epochs):
            for batch_X, batch_y in loader:
                batch_X, batch_y = batch_X.to(self.device), batch_y.to(self.device)
                optimizer.zero_grad()
                pred = self.model(batch_X)
                loss = criterion(pred.squeeze(), batch_y)
                loss.backward()
                optimizer.step()
                losses.append(loss.item())

        self.last_train_loss = np.mean(losses) if losses else 0.0
        self.is_trained = True
        return True

    # ------------------------------------------------------------
    # PREDICTION V6: EV & MQS Gated Inference
    # ------------------------------------------------------------
    def predict(self, df):
        """
        Zwraca: (predicted_price, confidence, signal)
        Zasada: EV (Expected Value) > Threshold
        """
        # 1. Walidacja danych
        last_close = df['close'].iloc[-1]
        if len(df) < self.lookback + 5:
            return last_close, 0.0, "HOLD"

        # 2. MQS HARD GATE (Filtr ToksycznoÅ›ci)
        # JeÅ›li rynek jest "Å›mieciowy", nie tracimy czasu na AI
        mqs, _ = MarketRegime.analyze(df)
        if mqs < 35:
            return last_close, 0.0, "HOLD"

        # 3. Auto-Train (Local Context Adaptation)
        if self.model is None:
            if not self.train_on_fly(df):
                return last_close, 0.0, "ERROR"

        # 4. Przygotowanie tensora
        X, _ = self._prepare_data(df, is_inference=True)
        if X is None: return last_close, 0.0, "ERROR"
        seq = torch.tensor(X[-1]).unsqueeze(0).float().to(self.device)

        # 5. MONTE CARLO DROPOUT INFERENCE
        self.model.train() # Wymuszamy dropout
        mc_preds = []
        iterations = 25

        with torch.no_grad():
            for _ in range(iterations):
                mc_preds.append(self.model(seq).item())

        # 6. Statystyka Bayesowska
        mean_log_ret = np.mean(mc_preds)
        std_dev = np.std(mc_preds) # Epistemic Uncertainty

        # 7. Dynamiczna Kalibracja Confidence
        # Sensitivity dostosowane do zmiennoÅ›ci (im wyÅ¼szy ATR, tym mniejsza kara za szum)
        current_atr = df['atr'].iloc[-1]
        atr_pct = (current_atr / last_close) * 100
        # Bazowe sensitivity 80, Å‚agodzone przez ATR (max divisor 2.0)
        dynamic_sensitivity = 80.0 / max(1.0, atr_pct)

        confidence = 1.0 / (1.0 + dynamic_sensitivity * std_dev)
        confidence = max(0.0, min(1.0, confidence))

        # 8. Konwersja na CenÄ™
        predicted_price = last_close * np.exp(mean_log_ret)

        # 9. EXPECTED VALUE (EV) CALCULATION
        # EV = (Potencjalny Zysk * PrawdopodobieÅ„stwo) - (Szum * (1 - PrawdopodobieÅ„stwo))
        move_pct = (predicted_price - last_close) / last_close * 100

        # JeÅ›li confidence jest niskie, traktujemy ruch jako noise risk
        ev_score = (move_pct * confidence) - (abs(move_pct) * (1 - confidence) * 0.5)

        # 10. Generowanie SygnaÅ‚u (Instytucjonalny PrÃ³g)
        signal = "HOLD"

        # Wymagamy: Dodatniego EV, Wysokiego MQS i Min. Confidence
        if ev_score > 0.15 and confidence > 0.55 and mqs > 40:
            signal = "BUY"
        elif ev_score < -0.15 and confidence > 0.55 and mqs > 40:
            signal = "SELL"

        # Reinforcement Learning Snapshot
        if confidence > 0.7:
            try:
                snap = {
                    "ev": ev_score,
                    "conf": confidence,
                    "std": std_dev,
                    "mqs": mqs
                }
                KnowledgeBase.save_pattern("brain_v6", snap, 1.0 if signal == "BUY" else 0.0)
            except: pass

        return predicted_price, confidence, signal

==================================================
FILE: ml\knowledge.py
==================================================
import os
import json
import pandas as pd
from datetime import datetime

class KnowledgeBase:
    """
    PamiÄ™Ä‡ DÅ‚ugotrwaÅ‚a V2.5 - Versioned Rolling Buffer.
    """
    MAX_RECORDS = 1000

    @staticmethod
    def _get_db_path(user):
        if not os.path.exists("assets"): os.makedirs("assets")
        return os.path.join("assets", f"brain_cortex_{user}.json")

    @staticmethod
    def save_pattern(user, features, label):
        db_file = KnowledgeBase._get_db_path(user)
        data = []
        if os.path.exists(db_file):
            try:
                with open(db_file, "r") as f: data = json.load(f)
            except: data = []

        record = features.copy()
        record['target'] = label
        record['ts'] = datetime.now().isoformat()
        record['ver'] = "V4.5"

        data.append(record)

        if len(data) > KnowledgeBase.MAX_RECORDS:
            excess = len(data) - KnowledgeBase.MAX_RECORDS
            data = data[excess:]

        try:
            with open(db_file, "w") as f: json.dump(data, f, indent=4)
        except Exception: return 0
        return len(data)

    @staticmethod
    def load_training_data(user):
        db_file = KnowledgeBase._get_db_path(user)
        if not os.path.exists(db_file): return pd.DataFrame()
        try:
            with open(db_file, "r") as f: data = json.load(f)
            return pd.DataFrame(data)
        except: return pd.DataFrame()

    @staticmethod
    def clear_memory(user):
        db_file = KnowledgeBase._get_db_path(user)
        if os.path.exists(db_file):
            os.remove(db_file)
            return True
        return False

==================================================
FILE: ml\regime.py
==================================================
import numpy as np

class MarketRegime:
    """
    V2.5: Market Quality Score + Safety Clamp.
    """

    @staticmethod
    def calculate_efficiency_ratio(close_series, period=10):
        if len(close_series) < period + 1: return 0.0
        change = abs(close_series.iloc[-1] - close_series.iloc[-period - 1])
        volatility = np.sum(np.abs(close_series.diff().tail(period)))
        if volatility == 0: return 0.0
        return change / volatility

    @staticmethod
    def analyze(df):
        if df.empty or len(df) < 20:
            return 0, "NO_DATA"

        try:
            adx = df['adx'].iloc[-1] if 'adx' in df else 0
            bb_width = df['bb_width'].iloc[-1] if 'bb_width' in df else 0
            rsi = df['rsi'].iloc[-1] if 'rsi' in df else 50
            er = MarketRegime.calculate_efficiency_ratio(df['close'], 10)

            score = 0
            # A. Czystosc
            if er > 0.6: score += 30
            elif er > 0.3: score += 15

            # B. Trend
            if 25 < adx < 60: score += 30
            elif adx >= 60: score += 15

            # C. Zmiennosc
            if 0.05 < bb_width < 0.30: score += 20

            # D. Momentum
            if 40 < rsi < 80: score += 20

            # Normalizacja (Safety Clamp)
            score = max(0, min(100, score))

            if score >= 80: regime = "SNIPER (Perfect Trend)"
            elif score >= 50: regime = "STANDARD (Tradeable)"
            else: regime = "TOXIC (Chop/Noise)"

            return score, regime

        except Exception as e:
            return 0, "DATA_ERROR"

==================================================
FILE: ml\scanner.py
==================================================
import ccxt
import pandas as pd
import numpy as np
import os
from datetime import datetime

# CORE IMPORTS
from data.feed import DataFeed
from ml.brain import DeepBrain
from ml.regime import MarketRegime
from data.indicators import TechnicalIndicators
from core.event_logger import EventLogger  # <--- NOWOÅšÄ†

class MarketScanner:
    """
    REDLINE Market Scanner V6 (Ops-Ready).
    Zintegrowany z EventLoggerem: Generuje SIGNAL_ID dla kaÅ¼dego setupu.
    """

    def __init__(self, timeframe="1h"):
        self.tf = timeframe
        self.htf = "4h"
        self.brain = DeepBrain()
        self.output_path = os.path.join("assets", "scan_log.csv")

    def get_top_volume_symbols(self, limit=50):
        try:
            ex = ccxt.binance()
            tickers = ex.fetch_tickers()
            valid_tickers = [
                data for symbol, data in tickers.items()
                if "/USDT" in symbol and "UP/" not in symbol and "DOWN/" not in symbol
            ]
            sorted_tickers = sorted(valid_tickers, key=lambda x: x['quoteVolume'], reverse=True)
            return [t['symbol'] for t in sorted_tickers[:limit]]
        except:
            return ["BTC/USDT", "ETH/USDT", "SOL/USDT", "BNB/USDT"]

    def _get_htf_trend(self, symbol):
        try:
            df = DataFeed.get_market_data(symbol, self.htf, limit=100)
            if df.empty: return "NEUTRAL"
            if 'ema_50' not in df.columns: df = TechnicalIndicators.add_all(df)
            return "BULLISH" if df['close'].iloc[-1] > df['ema_50'].iloc[-1] else "BEARISH"
        except:
            return "NEUTRAL"

    def scan(self):
        results = []
        symbols = self.get_top_volume_symbols(limit=50)

        print(f"--- OPS SCAN START: {len(symbols)} Assets ---")

        for i, symbol in enumerate(symbols):
            try:
                # 1. Dane LTF
                df = DataFeed.get_market_data(symbol, self.tf, limit=100)
                if df.empty or len(df) < 60: continue

                # 2. Regime
                mqs, _ = MarketRegime.analyze(df)
                if mqs < 35: continue

                # 3. AI Prediction
                pred_price, conf, signal = self.brain.predict(df)
                if conf < 0.60: continue

                # 4. HTF Context
                htf_trend = self._get_htf_trend(symbol)
                if signal == "BUY" and htf_trend == "BEARISH" and mqs < 80:
                    continue

                # 5. EV Calculation
                last_price = df["close"].iloc[-1]
                growth_pct = (pred_price - last_price) / last_price * 100

                atr = df['atr'].iloc[-1] if 'atr' in df else (last_price * 0.01)
                vol_pct = (atr / last_price) * 100 or 1.0
                rr = growth_pct / vol_pct

                # EV Score (Uproszczony na potrzeby logowania)
                ev_val = (growth_pct * conf) - (abs(growth_pct) * (1 - conf))

                final_score = (conf ** 1.5) * rr * 100

                # 6. LOGOWANIE SYGNAÅU (EventLogger)
                # Generujemy unikalny ID dla tego pomysÅ‚u
                signal_id = EventLogger.log_signal(
                    symbol=symbol,
                    tf=self.tf,
                    signal=signal,
                    conf=conf,
                    mqs=mqs,
                    htf_trend=htf_trend,
                    ev=ev_val,
                    reasons=["AI_HIT", "MQS_OK", f"SCORE_{final_score:.1f}"]
                )

                results.append({
                    "signal_id": signal_id, # <--- KLUCZOWE: Przekazujemy ID dalej
                    "symbol": symbol,
                    "signal": signal,
                    "conf": round(conf, 2),
                    "mqs": mqs,
                    "score": round(final_score, 2),
                    "current_price": last_price,
                    "ev": ev_val,
                    "ts": datetime.now().strftime("%H:%M")
                })

                print(f"[{i+1}] {symbol}: HIT! ID: {signal_id}")

            except Exception as e:
                print(f"Error {symbol}: {e}")
                continue

        if results:
            ranked = pd.DataFrame(results).sort_values("score", ascending=False)
            return ranked
        else:
            return pd.DataFrame()

==================================================
FILE: ml\training.py
==================================================
import os
import time
import json
import pandas as pd
import torch
from datetime import datetime
from core.logger import log_event
from ml.brain import DeepBrain
from ml.knowledge import KnowledgeBase
from data.feed import DataFeed

class OfflineTrainer:
    def __init__(self):
        self.brain = DeepBrain()
        self.is_running = False
        self.report_path = os.path.join("assets", "training_report.json")

    def run_training_session(self, assets, timeframe="1h", epochs=50):
        self.is_running = True
        log_event("TRAINING SEQUENCE INITIATED (V4.5 MLOps)", "INFO")

        start_time = time.time()
        results = {
            "timestamp": datetime.now().isoformat(),
            "model_version": "DeepBrain V4.5",
            "timeframe": timeframe,
            "epochs": epochs,
            "device": str(self.brain.device),
            "assets": [],
            "errors": [],
            "duration_sec": None
        }

        try:
            log_event("LOADING KNOWLEDGE BASE MEMORY...", "INFO")
            kb_df = KnowledgeBase.load_training_data("system_auto")
            if not kb_df.empty:
                log_event(f"FOUND {len(kb_df)} PATTERNS IN KNOWLEDGE BASE", "INFO")
            else:
                log_event("KNOWLEDGE BASE EMPTY - SKIPPING RL STAGE", "WARN")
        except Exception as e:
            log_event(f"KNOWLEDGE LOAD ERROR: {str(e)}", "ERROR")

        for symbol in assets:
            if not self.is_running:
                log_event("TRAINING INTERRUPTED", "WARN")
                break

            log_event(f"FETCHING MARKET DATA: {symbol} [{timeframe}]", "INFO")

            try:
                df = DataFeed.get_market_data(symbol, timeframe, limit=1000)

                if df is None or df.empty or len(df) < 200:
                    log_event(f"INSUFFICIENT DATA FOR {symbol}", "WARN")
                    results["errors"].append({"asset": symbol, "reason": "INSUFFICIENT_DATA"})
                    continue

                log_event(f"TRAINING MODEL ON {symbol} ({len(df)} rows)...", "INFO")
                success = self.brain.train_on_fly(df, epochs=epochs)

                if success:
                    loss_val = round(float(self.brain.last_train_loss), 6)

                    results["assets"].append({
                        "symbol": symbol,
                        "rows": len(df),
                        "arch": self.brain.current_arch,
                        "loss": loss_val,
                        "status": "SUCCESS"
                    })
                    log_event(f"MODEL UPDATED: {symbol} | Loss: {loss_val} | Arch: {self.brain.current_arch}", "succ")
                else:
                    results["errors"].append({"asset": symbol, "reason": "TRAINING_FAILED"})
                    log_event(f"MODEL TRAINING FAILED FOR {symbol}", "ERROR")

                if torch.cuda.is_available():
                    torch.cuda.empty_cache()

            except Exception as e:
                results["errors"].append({"asset": symbol, "reason": str(e)})
                log_event(f"CRITICAL TRAIN ERROR [{symbol}]: {str(e)}", "ERROR")

        duration = time.time() - start_time
        results["duration_sec"] = round(duration, 2)

        os.makedirs("assets", exist_ok=True)
        try:
            with open(self.report_path, "w") as f:
                json.dump(results, f, indent=4)
            log_event(f"TRAINING REPORT SAVED: {self.report_path}", "INFO")
        except Exception as e:
            log_event(f"FAILED TO SAVE TRAINING REPORT: {str(e)}", "ERROR")

        self.is_running = False
        summary = (
            f"SESSION COMPLETED | Duration: {results['duration_sec']}s | "
            f"Assets: {len(results['assets'])} | Errors: {len(results['errors'])}"
        )
        log_event(summary, "succ")
        return results

if __name__ == "__main__":
    trainer = OfflineTrainer()
    assets = ["BTC/USDT", "ETH/USDT", "SOL/USDT"]
    summary = trainer.run_training_session(assets=assets, timeframe="1h", epochs=50)
    print("\n=== OFFLINE TRAINING SUMMARY ===")
    print(json.dumps(summary, indent=4))

==================================================
FILE: ml\__init__.py
==================================================
from .brain import DeepBrain
from .regime import MarketRegime
from .knowledge import KnowledgeBase
from .training import OfflineTrainer

==================================================
FILE: redteam\audit.py
==================================================
import hashlib

class RedTeamOps:
    """NarzÄ™dzia audytowe (AUTHORIZED USE ONLY)"""

    @staticmethod
    def crack_hash(target_hash):
        """Prosty sÅ‚ownikowy Å‚amacz haseÅ‚ MD5"""
        dictionary = [
            "admin", "123456", "password", "redline",
            "root", "Cyber_Fortress_X1", "qwerty"
        ]

        for pwd in dictionary:
            if hashlib.md5(pwd.encode()).hexdigest() == target_hash:
                return pwd

        return None

==================================================
FILE: redteam\chaos.py
==================================================
import random
import time
import numpy as np

class ChaosMonkey:
    """Chaos Engineering â€“ test odpornoÅ›ci systemu"""

    @staticmethod
    def inject_flash_crash(df):
        """Symuluje nagÅ‚y spadek ceny o 90% na ostatniej Å›wiecy"""
        df_corrupted = df.copy()
        if not df_corrupted.empty:
            last_idx = df_corrupted.index[-1]
            df_corrupted.at[last_idx, "close"] = df_corrupted.at[last_idx, "close"] * 0.10
        return df_corrupted

    @staticmethod
    def inject_latency():
        """Symuluje opÃ³Åºnienie sieciowe (lag)"""
        lag = random.uniform(1.5, 5.0)
        time.sleep(lag)
        return lag

    @staticmethod
    def inject_bad_data(df):
        """Wstrzykuje uszkodzone dane (NaN)"""
        df_corrupted = df.copy()
        if not df_corrupted.empty:
            last_idx = df_corrupted.index[-1]
            df_corrupted.at[last_idx, "close"] = np.nan
        return df_corrupted

==================================================
FILE: redteam\exchange.py
==================================================
import random

class ExchangeSimulator:
    """
    Symulator wrogiej gieÅ‚dy (Adversarial Broker).
    Testuje odpornoÅ›Ä‡ systemu na: Slippage, Partial Fills, Rejections.
    """

    @staticmethod
    def execute_order(side, price, qty):
        """
        Symuluje egzekucjÄ™ zlecenia w nieidealnych warunkach.
        Zwraca: {status, filled_qty, avg_price, reason}
        """
        # Rzut kostkÄ… losu (Entropy)
        roll = random.random()

        # SCENARIUSZ 1: ORDER REJECTED (10% szans)
        # Np. brak pÅ‚ynnoÅ›ci, bÅ‚Ä…d API, overload silnika gieÅ‚dy.
        if roll < 0.10:
            return {
                "status": "REJECTED",
                "filled_qty": 0.0,
                "avg_price": 0.0,
                "reason": "EXCHANGE_ENGINE_OVERLOAD"
            }

        # SCENARIUSZ 2: PARTIAL FILL + SLIPPAGE (20% szans)
        # Zlecenie wypeÅ‚nione tylko czÄ™Å›ciowo i po gorszej cenie.
        if roll < 0.30:
            # WypeÅ‚niamy od 10% do 50% zlecenia
            filled = qty * random.uniform(0.1, 0.5)

            # PoÅ›lizg cenowy 0.2% - 1.0% (przeciwko nam)
            slippage = random.uniform(0.002, 0.010)
            if side == "BUY":
                exec_price = price * (1 + slippage)
            else:
                exec_price = price * (1 - slippage)

            return {
                "status": "PARTIAL_FILL",
                "filled_qty": round(filled, 6),
                "avg_price": round(exec_price, 2),
                "reason": "INSUFFICIENT_LIQUIDITY"
            }

        # SCENARIUSZ 3: FULL FILL + STANDARD SLIPPAGE (70% szans)
        # Nawet przy peÅ‚nym wypeÅ‚nieniu cena rzadko jest idealna.
        slippage = random.uniform(0.0005, 0.002) # 0.05% - 0.2%
        if side == "BUY":
            exec_price = price * (1 + slippage)
        else:
            exec_price = price * (1 - slippage)

        return {
            "status": "FILLED",
            "filled_qty": qty,
            "avg_price": round(exec_price, 2),
            "reason": "OK"
        }

==================================================
FILE: redteam\forensics.py
==================================================
import gc
import streamlit as st

class MemoryForensics:
    """
    Analiza pamiÄ™ci procesu (RAM Scraping).
    Sprawdza, czy po wylogowaniu w pamiÄ™ci nie zostaÅ‚y wraÅ¼liwe dane.
    """

    SUSPICIOUS_KEYS = [
        "api_key", "secret", "token", "password", "hash",
        "wallet", "private", "seed", "admin", "root"
    ]

    @staticmethod
    def scan_session_state():
        """Sprawdza obiekt session_state pod kÄ…tem wyciekÃ³w."""
        leaks = []

        # JeÅ›li jesteÅ›my wylogowani, 'sys' powinno byÄ‡ czyste lub zresetowane
        if "sys" in st.session_state:
            sys_dump = str(st.session_state["sys"])

            # Szukamy czy user/role nie wiszÄ… w pamiÄ™ci
            if "'auth': True" in sys_dump:
                leaks.append("CRITICAL: AUTH FLAG PERSISTED")
            if "admin" in sys_dump or "ROOT" in sys_dump:
                leaks.append("WARN: USER DATA PERSISTED IN SYS")

        return leaks

    @staticmethod
    def scan_runtime_objects():
        """
        GÅ‚Ä™boki skan obiektÃ³w Pythona (Garbage Collector).
        Symuluje atakujÄ…cego, ktÃ³ry ma dostÄ™p do zrzutu pamiÄ™ci procesu.
        """
        findings = []
        try:
            # Iterujemy po obiektach w pamiÄ™ci (OSTROÅ»NIE - to ciÄ™Å¼ka operacja)
            # Sprawdzamy tylko sÅ‚owniki, bo tam najczÄ™Å›ciej siedzÄ… configi
            for obj in gc.get_objects():
                if isinstance(obj, dict):
                    # Sprawdzamy klucze sÅ‚ownika
                    for k in obj.keys():
                        if isinstance(k, str):
                            if any(s in k.lower() for s in MemoryForensics.SUSPICIOUS_KEYS):
                                # Ignorujemy wewnÄ™trzne zmienne Pythona/Streamlita
                                val_str = str(obj[k])[:50] # PodglÄ…d wartoÅ›ci
                                if "streamlit" not in val_str and "module" not in val_str:
                                    findings.append(f"FOUND TRACE: {k} = {val_str}...")

                if len(findings) > 5: break # Limit wynikÃ³w dla bezpieczeÅ„stwa testu
        except:
            return ["SCAN ERROR (PERMISSION/MEMORY)"]

        return findings

==================================================
FILE: redteam\manipulation.py
==================================================
import numpy as np
import pandas as pd

class AdversarialMarket:
    """
    Generuje dane rynkowe typu 'Bull Trap'.
    Celem jest oszukanie modelu ML, by daÅ‚ sygnaÅ‚ BUY na szczycie.
    """

    @staticmethod
    def generate_false_trend(df):
        """
        Modyfikuje ostatnie 15 Å›wiec, tworzÄ…c idealny, sztuczny trend.
        """
        df_adv = df.copy()
        n = len(df_adv)

        # Potrzebujemy min. 20 Å›wiec do manipulacji
        if n < 20:
            return df_adv

        # 1. Mikro-wzrosty (Stable Grind Up)
        # To oszukuje algorytmy oparte na Å›rednich kroczÄ…cych.
        # Generujemy seriÄ™ maÅ‚ych, pozytywnych zwrotÃ³w.
        fake_returns = np.random.normal(0.002, 0.0005, 15) # +0.2% avg

        # 2. Sztuczne podbijanie ceny (Painting the Tape)
        current_price = df_adv['close'].iloc[-16]
        for i in range(15):
            idx = n - 15 + i
            current_price = current_price * (1 + fake_returns[i])
            df_adv.at[df_adv.index[idx], 'close'] = current_price

            # High/Low teÅ¼ muszÄ… wyglÄ…daÄ‡ "bezpiecznie" (maÅ‚a zmiennoÅ›Ä‡)
            df_adv.at[df_adv.index[idx], 'h'] = current_price * 1.001
            df_adv.at[df_adv.index[idx], 'l'] = current_price * 0.999

        # 3. FaÅ‚szowanie Wolumenu (Volume Masking)
        # Ustawiamy wolumen na Å›redni poziom, Å¼eby nie uruchomiÄ‡ alarmÃ³w "Low Volume".
        avg_vol = df_adv['v'].mean()
        df_adv.iloc[-15:, df_adv.columns.get_loc('v')] = avg_vol * np.random.uniform(0.9, 1.1, 15)

        # 4. Manipulacja RSI (Divergence Hiding)
        # RÄ™cznie ustawiamy RSI w strefie "Safe Bullish" (55-68), unikajÄ…c Overbought (>70).
        # To najbardziej myli boty.
        fake_rsi = np.linspace(55, 68, 15)
        if 'rsi' in df_adv.columns:
            df_adv.iloc[-15:, df_adv.columns.get_loc('rsi')] = fake_rsi

        return df_adv

==================================================
FILE: redteam\osint.py
==================================================
import random
import requests

class OsintOps:
    """ModuÅ‚ OSINT / Recon & Stealth"""

    @staticmethod
    def generate_dorks(target):
        """Generuje zapytania Google Dorking dla celu"""
        base = "https://www.google.com/search?q="
        queries = [
            ("CONFIDENTIAL PDF", f'site:*.{target}.com filetype:pdf "confidential"'),
            ("EXPOSED DB", f'site:*.{target}.com ext:sql | ext:dbf | ext:mdb'),
            ("LOGIN PORTALS", f'site:*.{target}.com inurl:login'),
            ("GITHUB SECRETS", f'site:github.com "{target}" "API_KEY"')
        ]

        return [(name, base + requests.utils.quote(q)) for name, q in queries]

    @staticmethod
    def stealth_headers():
        """Generuje faÅ‚szywe nagÅ‚Ã³wki przeglÄ…darki (User-Agent)"""
        agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36"
        ]

        return {
            "User-Agent": random.choice(agents)
        }

==================================================
FILE: redteam\__init__.py
==================================================
from .osint import OsintOps
from .exchange import ExchangeSimulator
from .manipulation import AdversarialMarket
from .forensics import MemoryForensics
from .chaos import ChaosMonkey

==================================================
FILE: security\hardware.py
==================================================
# ===========================================
# REDLINE V68 - HardwareSecurity V4.6.1
# ===========================================

import os, hashlib, secrets

class HardwareSecurity:
    KEY_FILENAME = "redline.key"
    EXPECTED_HASH = "replace_with_your_generated_hash"  # SHA256 hash of key content

    @staticmethod
    def verify_key(mount_path="E:/"):
        """Verifies a hardware key file by SHA256 hash."""
        try:
            key_path = os.path.join(mount_path, HardwareSecurity.KEY_FILENAME)
            if not os.path.exists(key_path):
                return False
            with open(key_path, "r") as f:
                content = f.read().strip()
            file_hash = hashlib.sha256(content.encode()).hexdigest()
            return secrets.compare_digest(file_hash, HardwareSecurity.EXPECTED_HASH)
        except Exception:
            return False

    @staticmethod
    def generate_key_file(path="E:/"):
        """Generates a new hardware key file and prints its hash."""
        token = secrets.token_hex(32)
        key_path = os.path.join(path, HardwareSecurity.KEY_FILENAME)
        with open(key_path, "w") as f:
            f.write(token)
        hash_val = hashlib.sha256(token.encode()).hexdigest()
        print("[HardwareSecurity] Key generated successfully.")
        print("Store this hash securely:", hash_val)

==================================================
FILE: security\network.py
==================================================
import requests
from .user_manager import UserManager

class NetworkSentinel:
    """
    Ochrona Sieciowa: IP Allowlist & Geo-Check.
    V3: Zabezpieczona przed 'Fallback Root Escalation'.
    """

    FALLBACK_IP = "127.0.0.1"

    @staticmethod
    def get_ip():
        """Pobiera IP z krÃ³tkim timeoutem."""
        try:
            ip = requests.get('https://api.ipify.org', timeout=3).text
            return ip
        except:
            return NetworkSentinel.FALLBACK_IP

    @staticmethod
    def check_access(user, current_ip):
        db = UserManager.load_db()

        if user not in db['active']:
            return False

        user_data = db['active'][user]
        allowed_ips = user_data.get('allowed_ips', [])

        # FIRST BLOOD RULE: Auto-Add dla Roota
        if not allowed_ips and user_data['role'] == "ROOT":
            # ðŸ›¡ï¸ SECURITY FIX: Nie pozwalamy na auto-add, jeÅ›li IP to fallback!
            # JeÅ›li API padÅ‚o, nie moÅ¼emy ufaÄ‡, Å¼e 127.0.0.1 to prawowity admin.
            if current_ip == NetworkSentinel.FALLBACK_IP:
                return False

            NetworkSentinel.authorize_new_ip(user, current_ip)
            return True

        if current_ip in allowed_ips:
            return True

        return False

    @staticmethod
    def authorize_new_ip(user, current_ip):
        # Dodatkowe zabezpieczenie: nigdy nie dodawaj localhosta do bazy
        if current_ip == NetworkSentinel.FALLBACK_IP:
            return False

        db = UserManager.load_db()
        if user in db['active']:
            if 'allowed_ips' not in db['active'][user]:
                db['active'][user]['allowed_ips'] = []

            if current_ip not in db['active'][user]['allowed_ips']:
                db['active'][user]['allowed_ips'].append(current_ip)
                UserManager.save_db(db)
                return True
        return False

==================================================
FILE: security\user_manager.py
==================================================
import json
import os
import secrets
import hashlib
from datetime import datetime

class UserManager:
    """
    System ZarzÄ…dzania ToÅ¼samoÅ›ciÄ… (IAM).
    ObsÅ‚uguje logowanie, hashowanie i system prÃ³Å›b o dostÄ™p.
    """

    DB_FILE = os.path.join("assets", "users_db.json")

    # DomyÅ›lny Root (admin / admin123) - SHA256
    DEFAULT_ROOT = {
        "admin": {
            "hash": "240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9",
            "role": "ROOT",
            "contact": "sysadmin",
            "created": "2026-01-01"
        }
    }

    @staticmethod
    def _ensure_assets():
        if not os.path.exists("assets"):
            os.makedirs("assets")

    @staticmethod
    def hash_password(password):
        """Pomocnicza funkcja do hashowania (SHA-256)."""
        return hashlib.sha256(password.encode()).hexdigest()

    @staticmethod
    def load_db():
        """Åaduje bazÄ™ z obsÅ‚ugÄ… bÅ‚Ä™dÃ³w JSON."""
        UserManager._ensure_assets()

        # Inicjalizacja, jeÅ›li plik nie istnieje
        if not os.path.exists(UserManager.DB_FILE):
            db = {"active": UserManager.DEFAULT_ROOT.copy(), "pending": {}}
            UserManager.save_db(db)
            return db

        try:
            with open(UserManager.DB_FILE, "r") as f:
                return json.load(f)
        except json.JSONDecodeError:
            return {"active": UserManager.DEFAULT_ROOT.copy(), "pending": {}}

    @staticmethod
    def save_db(db):
        UserManager._ensure_assets()
        with open(UserManager.DB_FILE, "w") as f:
            json.dump(db, f, indent=4)

    @staticmethod
    def verify_login(user, plain_password):
        """
        Weryfikuje uÅ¼ytkownika i hasÅ‚o.
        FIX: Hashuje hasÅ‚o wejÅ›ciowe przed porÃ³wnaniem z bazÄ….
        """
        db = UserManager.load_db()

        if user in db['active']:
            stored_data = db['active'][user]
            stored_hash = stored_data.get('hash', '')

            # Hashujemy wpisane hasÅ‚o, aby pasowaÅ‚o do formatu w bazie
            input_hash = UserManager.hash_password(plain_password)

            # Bezpieczne porÃ³wnanie hashÃ³w
            if secrets.compare_digest(stored_hash, input_hash):
                return stored_data.get('role', 'VIEWER')

        return None

    @staticmethod
    def request_account(username, password, contact):
        """Dodaje proÅ›bÄ™ o konto do kolejki 'pending'."""
        db = UserManager.load_db()

        if username in db['active']:
            return False, "User already active."

        if username in db['pending']:
            return False, "Request pending approval."

        db['pending'][username] = {
            "hash": UserManager.hash_password(password),
            "contact": contact,
            "ts": datetime.now().isoformat(),
            "status": "WAITING_FOR_ADMIN"
        }

        UserManager.save_db(db)
        return True, "Request submitted to Admin."

    @staticmethod
    def approve_user(user, role="USER"):
        db = UserManager.load_db()
        if user in db['pending']:
            user_data = db['pending'].pop(user)
            user_data['role'] = role
            user_data['allowed_ips'] = []
            db['active'][user] = user_data
            UserManager.save_db(db)
            return True
        return False

    @staticmethod
    def reject_user(user):
        db = UserManager.load_db()
        if user in db['pending']:
            del db['pending'][user]
            UserManager.save_db(db)
            return True
        return False

==================================================
FILE: security\vault.py
==================================================
import os
import json
import streamlit as st
from cryptography.fernet import Fernet

class Vault:
    """
    ModuÅ‚ obronny: Szyfrowanie Portfela (AES-128 via Fernet).
    V3.1: Skonfigurowany pod Trading System (Startowe $10k).
    """

    KEY_FILE = os.path.join("assets", "redline.key")
    WALLET_FILE = os.path.join("assets", "wallet.enc")
    DECOY_FILE = os.path.join("assets", "honeypot.txt")

    @staticmethod
    def _ensure_assets_dir():
        if not os.path.exists("assets"):
            os.makedirs("assets")

    @staticmethod
    def _get_cipher():
        """Pobiera klucz. NIGDY nie generuje nowego, jeÅ›li istnieje osierocony portfel."""
        Vault._ensure_assets_dir()

        # --- CRITICAL SAFETY CHECK ---
        # JeÅ›li portfel istnieje, ale klucza brak -> STOP!
        if os.path.exists(Vault.WALLET_FILE) and not os.path.exists(Vault.KEY_FILE):
            st.error("ðŸš¨ CRITICAL: ORPHANED WALLET DETECTED. KEY MISSING. ABORTING.")
            return None

        # Generowanie klucza TYLKO jeÅ›li to czysta instalacja
        if not os.path.exists(Vault.KEY_FILE):
            try:
                key = Fernet.generate_key()
                with open(Vault.KEY_FILE, "wb") as f:
                    f.write(key)
            except Exception:
                return None

        try:
            with open(Vault.KEY_FILE, "rb") as f:
                key = f.read()
            return Fernet(key)
        except Exception:
            return None

    @staticmethod
    def load_wallet():
        """Bezpieczny odczyt portfela."""
        # 1. Sprawdzenie LOCKDOWN (Red Team simulation)
        if st.session_state.get("sys", {}).get("breach", False):
            return {"balance": 0, "assets": [], "history": [], "LOCKED": True}

        cipher = Vault._get_cipher()

        # JeÅ›li cipher jest None
        if cipher is None:
            return {"balance": 0, "assets": [], "ERROR": "FATAL_KEY_ERROR"}

        # 2. Inicjalizacja (tylko jeÅ›li plik nie istnieje)
        if not os.path.exists(Vault.WALLET_FILE):
            # --- ZMIANA TUTAJ: Dajemy $10,000 na start ---
            data = {
                "balance": 10000.00,
                "assets": [],
                "history": [],
                "LOCKED": False # Wymagane przez execution.py
            }
            Vault.save_wallet(data)
            return data

        # 3. PrÃ³ba deszyfracji
        try:
            with open(Vault.WALLET_FILE, "rb") as f:
                encrypted_data = f.read()
            decrypted_json = cipher.decrypt(encrypted_data).decode()
            return json.loads(decrypted_json)
        except Exception:
            return {"balance": 0, "assets": [], "history": [], "ERROR": "DECRYPT_FAIL"}

    @staticmethod
    def save_wallet(data):
        cipher = Vault._get_cipher()
        if cipher:
            try:
                encrypted = cipher.encrypt(json.dumps(data).encode())
                with open(Vault.WALLET_FILE, "wb") as f:
                    f.write(encrypted)
                return True
            except Exception:
                return False
        return False

    @staticmethod
    def deploy_honeypot():
        Vault._ensure_assets_dir()
        try:
            with open(Vault.DECOY_FILE, "w") as f:
                f.write("root_user: admin\npass: 123456\nseed: apple banana cherry\nBTC_WALLET: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa")
            return True
        except:
            return False

==================================================
FILE: security\__init__.py
==================================================
from .user_manager import UserManager
from .network import NetworkSentinel
from .hardware import HardwareSecurity
from .vault import Vault

==================================================
FILE: trading\analytics.py
==================================================
import pandas as pd
import numpy as np
from trading.wallet import WalletManager

class TradeAnalytics:
    """
    MODUÅ ANALITYCZNY (EX-POST).
    Liczy KPI: WinRate, Expectancy, Drawdown, Profit Factor.
    """

    @staticmethod
    def generate_report():
        wallet = WalletManager.get_wallet_data()
        history = wallet.get('history', [])

        # Filtrujemy tylko zamkniÄ™te transakcje (gdzie jest pnl_val)
        trades = [h for h in history if isinstance(h, dict) and 'pnl_val' in h]

        if not trades:
            return {
                "total_trades": 0,
                "win_rate": 0.0,
                "profit_factor": 0.0,
                "expectancy": 0.0,
                "max_drawdown": 0.0,
                "net_profit": 0.0
            }

        df = pd.DataFrame(trades)

        # 1. Podstawowe metryki
        total_trades = len(df)
        wins = df[df['pnl_val'] > 0]
        losses = df[df['pnl_val'] <= 0]

        win_rate = (len(wins) / total_trades) * 100 if total_trades > 0 else 0
        net_profit = df['pnl_val'].sum()

        # 2. Profit Factor & Expectancy
        gross_profit = wins['pnl_val'].sum()
        gross_loss = abs(losses['pnl_val'].sum())

        profit_factor = round(gross_profit / gross_loss, 2) if gross_loss > 0 else float('inf')

        avg_win = wins['pnl_val'].mean() if not wins.empty else 0
        avg_loss = losses['pnl_val'].mean() if not losses.empty else 0

        # EV = (Win% * AvgWin) - (Loss% * AvgLoss)
        win_dec = win_rate / 100
        expectancy = (win_dec * avg_win) + ((1 - win_dec) * avg_loss)

        # 3. Max Drawdown (Symulacja krzywej kapitaÅ‚u)
        df['equity_curve'] = df['pnl_val'].cumsum()
        df['peak'] = df['equity_curve'].cummax()
        df['drawdown'] = df['equity_curve'] - df['peak']
        max_dd = df['drawdown'].min()

        return {
            "total_trades": total_trades,
            "win_rate": round(win_rate, 2),
            "profit_factor": profit_factor,
            "expectancy": round(expectancy, 2), # Oczekiwany zysk na 1 trade
            "max_drawdown": round(max_dd, 2),
            "net_profit": round(net_profit, 2)
        }

==================================================
FILE: trading\capital.py
==================================================
class CapitalGuard:
    """
    V68: Dynamiczna Agresja oparta na MQS.
    Wersja HARDENED: Odporna na bÅ‚Ä™dy matematyczne i bÅ‚Ä™dne dane API.
    """

    @staticmethod
    def calculate_position_size(balance, price, mqs_score):
        # 1. Walidacja Krytyczna Danych WejÅ›ciowych (Anti-Crash)
        if balance <= 0:
            return 0.0, 0.0
        if price <= 0: # Ochrona przed dzieleniem przez zero
            return 0.0, 0.0

        # Clamp mqs_score do zakresu 0-100 (na wszelki wypadek)
        mqs_score = max(0, min(100, mqs_score))

        # Baza: Maksymalnie 15% kapitaÅ‚u na pozycjÄ™ w idealnych warunkach
        MAX_RISK = 0.15

        # Funkcja agresji: Kwadratowa (karze niskie wyniki, nagradza wysokie)
        # Przy MQS 50 -> aggression = 0.25 (25% mocy)
        aggression_factor = (mqs_score / 100.0) ** 2

        usd_size = balance * MAX_RISK * aggression_factor

        # Hard Limit: Nie wiÄ™cej niÅ¼ 98% salda (zostawiamy na fees)
        if usd_size > balance * 0.98:
            usd_size = balance * 0.98

        # Min. wielkoÅ›Ä‡ zlecenia (np. $11 dla Binance)
        if usd_size < 11.0:
            usd_size = 0.0

        # Obliczenie iloÅ›ci (zabezpieczone, bo price > 0 sprawdzone wyÅ¼ej)
        qty = usd_size / price

        # ZaokrÄ…glenie finansowe (2 miejsca dla USD, 6 dla krypto)
        return round(usd_size, 2), round(qty, 6)

==================================================
FILE: trading\decision.py
==================================================
from datetime import datetime, time
from trading.wallet import WalletManager
from trading.capital import CapitalGuard
from data.feed import DataFeed
from core.event_logger import EventLogger  # <--- NOWOÅšÄ†

class DecisionEngine:
    """
    STRAÅ»NIK RYZYKA V4 (Ops-Connected).
    Loguje kaÅ¼dÄ… decyzjÄ™ (TAK/NIE) do EventLoggera.
    """

    def __init__(self, mode="PAPER"):
        self.mode = mode
        self.max_concurrent_positions = 3
        self.min_confidence = 0.60

        self.COOLDOWN_MINUTES = 60
        self.SESSION_START = time(7, 0)
        self.SESSION_END = time(21, 0)

    def _check_session(self):
        now = datetime.utcnow().time()
        return self.SESSION_START <= now <= self.SESSION_END

    def _check_cooldown(self, symbol):
        wallet = WalletManager.get_wallet_data()
        history = wallet.get('history', [])

        last_trade_ts = None
        for trade in reversed(history):
            if isinstance(trade, dict) and trade.get('symbol') == symbol:
                last_trade_ts = trade.get('ts')
                break

        if last_trade_ts:
            try:
                # ObsÅ‚uga formatu ISO z EventLoggera lub prostego czasu
                if "T" in last_trade_ts:
                    last_dt = datetime.fromisoformat(last_trade_ts)
                else:
                    # Fallback dla starego formatu
                    last_dt = datetime.strptime(last_trade_ts, "%H:%M:%S")
                    now = datetime.now()
                    last_dt = last_dt.replace(year=now.year, month=now.month, day=now.day)

                diff = (datetime.now() - last_dt).total_seconds() / 60
                if diff < self.COOLDOWN_MINUTES:
                    return False, f"COOLDOWN ({int(diff)}m)"
            except: pass

        return True, "OK"

    def evaluate_entry(self, candidate, risk_status=True):
        """
        Zwraca: (approved, reason, size_usd)
        Oraz LOGUJE decyzjÄ™.
        """
        symbol = candidate['symbol']
        signal = candidate['signal']
        signal_id = candidate.get('signal_id', 'MANUAL') # Pobieramy ID ze skanera

        reasons = []
        checks = {}
        approved = False
        final_reason = "UNKNOWN"
        size_usd = 0.0

        # --- LOGIKA DECYZYJNA ---
        try:
            # 1. Global Risk
            checks['global_risk'] = risk_status
            if not risk_status:
                final_reason = "KILL_SWITCH"
                raise StopIteration

            # 2. Session
            sess_ok = self._check_session()
            checks['session'] = sess_ok
            if not sess_ok:
                final_reason = "OUT_OF_SESSION"
                raise StopIteration

            # 3. Cooldown
            cool_ok, cool_msg = self._check_cooldown(symbol)
            checks['cooldown'] = cool_ok
            if not cool_ok:
                final_reason = cool_msg
                raise StopIteration

            # 4. Portfolio
            wallet = WalletManager.get_wallet_data()
            curr_assets = [a['sym'] for a in wallet.get('assets', [])]
            if symbol in curr_assets:
                final_reason = "ALREADY_IN_POS"
                raise StopIteration

            if len(curr_assets) >= self.max_concurrent_positions:
                final_reason = "MAX_SLOTS_FULL"
                raise StopIteration

            # 5. Price & Size
            price = candidate.get('current_price', 0)
            if price <= 0:
                try:
                    df = DataFeed.get_market_data(symbol, "1m", limit=1)
                    price = df['close'].iloc[-1]
                except:
                    final_reason = "NO_PRICE_DATA"
                    raise StopIteration

            balance = wallet.get('balance', 0)
            mqs = candidate.get('mqs', 50)

            size, _ = CapitalGuard.calculate_position_size(balance, price, mqs)
            if size < 10:
                final_reason = "SIZE_TOO_SMALL"
                raise StopIteration

            # SUKCES
            approved = True
            final_reason = "APPROVED"
            size_usd = size

        except StopIteration:
            pass

        # --- LOGOWANIE ZDARZENIA ---
        EventLogger.log_decision(
            symbol=symbol,
            signal=signal,
            approved=approved,
            reason=final_reason,
            size_usd=size_usd,
            signal_id=signal_id,
            checks=checks
        )
        DecisionCore = DecisionEngine

        return approved, final_reason, size_usd

==================================================
FILE: trading\execution.py
==================================================
from datetime import datetime
from trading.wallet import WalletManager
from core.logger import log_event
from data.feed import DataFeed
from core.event_logger import EventLogger  # <--- NOWOÅšÄ†

class ExecutionEngine:
    """
    MODUÅ WYKONAWCZY V3 (Ops-Connected).
    Generuje TRADE_ID i zapisuje go w aktywach.
    """

    def __init__(self, mode="PAPER"):
        self.mode = mode

    def execute_order(self, symbol, side, amount_usd, signal_id=None):
        wallet = WalletManager.get_wallet_data()

        # 1. Price Check
        try:
            ticker_data = DataFeed.get_market_data(symbol, "1m", limit=1)
            if ticker_data.empty: return {'status': 'FAILED', 'reason': 'NO DATA'}
            fill_price = ticker_data['close'].iloc[-1]
        except Exception as e:
            return {'status': 'FAILED', 'reason': str(e)}

        qty = amount_usd / fill_price

        # 2. PAPER EXECUTION
        if self.mode == "PAPER":
            if side == "BUY":
                balance = wallet.get('balance', 0.0)
                if balance < amount_usd:
                    return {'status': 'FAILED', 'reason': 'NSF'}

                # --- LOGOWANIE EXECUTION ---
                # Generujemy Trade ID powiÄ…zany z Signal ID
                trade_id = EventLogger.log_execution(
                    symbol=symbol,
                    side=side,
                    entry_price=fill_price,
                    qty=qty,
                    cost=amount_usd,
                    order_status="FILLED",
                    signal_id=signal_id
                )

                # Aktualizacja portfela
                wallet['balance'] = round(balance - amount_usd, 2)
                if 'assets' not in wallet: wallet['assets'] = []

                wallet['assets'].append({
                    "trade_id": trade_id,  # <--- ZAPISUJEMY ID
                    "sym": symbol,
                    "entry": fill_price,
                    "amt": qty,
                    "cost": amount_usd,
                    "ts": datetime.now().isoformat(), # ISO format lepszy dla analityki
                    "sl": fill_price * 0.96,
                    "tp": fill_price * 1.06
                })

                WalletManager.save_wallet_data(wallet)
                log_event(f"[PAPER] BOUGHT {symbol} (ID: {trade_id})", "TRADE")

                return {'status': 'FILLED', 'avg_price': fill_price, 'trade_id': trade_id}

        return {'status': 'FAILED', 'reason': 'BAD MODE'}

    def close_position(self, symbol, position_data, exit_price, reason="MANUAL"):
        if self.mode == "PAPER":
            wallet = WalletManager.get_wallet_data()
            qty = position_data['amt']
            cost = position_data['cost']
            trade_id = position_data.get('trade_id', 'UNKNOWN') # Pobieramy ID

            revenue = qty * exit_price
            pnl = revenue - cost

            wallet['balance'] = round(wallet.get('balance', 0) + revenue, 2)

            # Obliczanie czasu trwania
            hold_min = 0
            try:
                entry_ts = datetime.fromisoformat(position_data['ts'])
                hold_min = (datetime.now() - entry_ts).total_seconds() / 60
            except: pass

            # --- LOGOWANIE WYJÅšCIA ---
            EventLogger.log_exit(
                symbol=symbol,
                entry_price=position_data['entry'],
                exit_price=exit_price,
                pnl=pnl,
                reason=reason,
                hold_time_min=hold_min,
                trade_id=trade_id
            )

            # Historia w portfelu (dla szybkiego UI)
            if 'history' not in wallet: wallet['history'] = []
            wallet['history'].append({
                "date": datetime.now().strftime('%Y-%m-%d'),
                "ts": datetime.now().isoformat(),
                "symbol": symbol,
                "action": "SELL",
                "pnl_val": round(pnl, 2),
                "desc": f"EXIT {symbol} | PnL: ${pnl:.2f}"
            })

            WalletManager.save_wallet_data(wallet)
            return True

        return False

==================================================
FILE: trading\position_manager.py
==================================================
from datetime import datetime, timedelta
from trading.wallet import WalletManager
from trading.execution import ExecutionEngine
from data.feed import DataFeed
from core.logger import log_event

class PositionManager:
    """
    ZARZÄ„DCA POZYCJI V3.
    Kompatybilny z nowym formatem daty w portfelu.
    """

    def __init__(self, mode="PAPER"):
        self.mode = mode
        self.executor = ExecutionEngine(mode)
        self.MAX_DAILY_LOSS_USD = -500.0
        self.MAX_HOLD_HOURS = 24
        self.kill_switch_active = False

    def get_daily_pnl(self):
        wallet = WalletManager.get_wallet_data()
        today_str = datetime.now().strftime('%Y-%m-%d')
        return sum(e.get('pnl_val', 0) for e in wallet.get('history', []) if e.get('date') == today_str)

    def check_global_risk(self):
        if self.kill_switch_active: return False, "KILL SWITCH"
        if self.get_daily_pnl() <= self.MAX_DAILY_LOSS_USD:
            self.kill_switch_active = True
            return False, "DAILY LOSS LIMIT"
        return True, "OK"

    def manage_positions(self):
        is_safe, _ = self.check_global_risk()
        if not is_safe: return

        wallet = WalletManager.get_wallet_data()
        assets = wallet.get('assets', [])
        if not assets: return

        dirty = False
        for pos in assets[:]:
            symbol = pos['sym']

            # ObsÅ‚uga daty (ISO vs Legacy)
            try:
                if "T" in pos['ts']:
                    entry_dt = datetime.fromisoformat(pos['ts'])
                else:
                    entry_dt = datetime.strptime(pos['ts'], "%Y-%m-%d %H:%M:%S")
            except:
                entry_dt = datetime.now()

            # Pobieramy cenÄ™
            try:
                df = DataFeed.get_market_data(symbol, "1m", limit=1)
                curr_price = df['close'].iloc[-1]
            except: continue

            # Warunki wyjÅ›cia
            reason = ""
            if curr_price <= pos.get('sl', 0): reason = "STOP LOSS"
            elif curr_price >= pos.get('tp', 999999): reason = "TAKE PROFIT"
            elif (datetime.now() - entry_dt) > timedelta(hours=self.MAX_HOLD_HOURS): reason = "TIME STOP"

            if reason:
                log_event(f"EXIT {symbol}: {reason}", "WARN")
                if self.executor.close_position(symbol, pos, curr_price, reason):
                    assets.remove(pos)
                    dirty = True

        if dirty:
            wallet['assets'] = assets
            WalletManager.save_wallet_data(wallet)

==================================================
FILE: trading\wallet.py
==================================================
from security.vault import Vault

class WalletManager:
    """ZarzÄ…dca stanu portfela (Read Ops)"""

    @staticmethod
    def get_wallet_data():
        return Vault.load_wallet()

    @staticmethod
    def get_balance():
        data = Vault.load_wallet()
        # JeÅ›li portfel jest zablokowany, zwracamy 0 dla bezpieczeÅ„stwa UI
        if data.get('LOCKED', False) or 'ERROR' in data:
            return 0.0
        return data.get('balance', 0.0)

    @staticmethod
    def get_assets():
        data = Vault.load_wallet()
        if data.get('LOCKED', False) or 'ERROR' in data:
            return []
        return data.get('assets', [])

    @staticmethod
    def save_wallet_data(data):
        Vault.save_wallet(data)

==================================================
FILE: trading\__init__.py
==================================================
from .decision import DecisionEngine
from .execution import ExecutionEngine
from .position_manager import PositionManager
from .wallet import WalletManager
from .capital import CapitalGuard
# JeÅ›li masz analytics:
from .analytics import TradeAnalytics
